"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/execute/route";
exports.ids = ["app/api/execute/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexecute%2Froute&page=%2Fapi%2Fexecute%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexecute%2Froute.js&appDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexecute%2Froute&page=%2Fapi%2Fexecute%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexecute%2Froute.js&appDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_VRAJ_SHAH_Desktop_jide_app_api_execute_route_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/execute/route.js */ \"(rsc)/./app/api/execute/route.js\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/execute/route\",\n        pathname: \"/api/execute\",\n        filename: \"route\",\n        bundlePath: \"app/api/execute/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\VRAJ SHAH\\\\Desktop\\\\jide\\\\app\\\\api\\\\execute\\\\route.js\",\n    nextConfigOutput,\n    userland: C_Users_VRAJ_SHAH_Desktop_jide_app_api_execute_route_js__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/execute/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZleGVjdXRlJTJGcm91dGUmcGFnZT0lMkZhcGklMkZleGVjdXRlJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZXhlY3V0ZSUyRnJvdXRlLmpzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNWUkFKJTIwU0hBSCU1Q0Rlc2t0b3AlNUNqaWRlJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNWUkFKJTIwU0hBSCU1Q0Rlc2t0b3AlNUNqaWRlJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNnQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2pwcC1pZGUvPzkyYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcVlJBSiBTSEFIXFxcXERlc2t0b3BcXFxcamlkZVxcXFxhcHBcXFxcYXBpXFxcXGV4ZWN1dGVcXFxccm91dGUuanNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2V4ZWN1dGUvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9leGVjdXRlXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9leGVjdXRlL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiQzpcXFxcVXNlcnNcXFxcVlJBSiBTSEFIXFxcXERlc2t0b3BcXFxcamlkZVxcXFxhcHBcXFxcYXBpXFxcXGV4ZWN1dGVcXFxccm91dGUuanNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2V4ZWN1dGUvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexecute%2Froute&page=%2Fapi%2Fexecute%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexecute%2Froute.js&appDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/execute/route.js":
/*!**********************************!*\
  !*** ./app/api/execute/route.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n// Use createRequire to load CommonJS modules in ES module context\nconst __filename = (0,url__WEBPACK_IMPORTED_MODULE_1__.fileURLToPath)(\"file:///C:/Users/VRAJ%20SHAH/Desktop/jide/app/api/execute/route.js\");\nconst __dirname = (0,path__WEBPACK_IMPORTED_MODULE_2__.dirname)(__filename);\nconst require = /* createRequire() */ undefined;\nlet compileJPlusPlus;\ntry {\n    // Use a static path so Webpack can resolve the dependency at build time\n    compileJPlusPlus = __webpack_require__(/*! ../../../lib/jpp/compiler.js */ \"(rsc)/./lib/jpp/compiler.js\");\n} catch (e) {\n    // If loading fails in the server environment, log and keep null so we can return a 500 at request time\n    compileJPlusPlus = null;\n    console.error(\"Failed to load J++ compiler:\", e && e.message ? e.message : e);\n}\n/**\r\n * POST /api/execute\r\n * Executes J++ code server-side\r\n * \r\n * Request body: { code: string }\r\n * Response: { success: boolean, output: string, ast: object, errors: array }\r\n */ async function POST(request) {\n    try {\n        const body = await request.json();\n        const { code } = body;\n        if (!compileJPlusPlus) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                code: null,\n                output: null,\n                ast: null,\n                errors: [\n                    {\n                        message: \"Server error: compiler not available\",\n                        type: \"server\"\n                    }\n                ]\n            }, {\n                status: 500\n            });\n        }\n        if (!code || typeof code !== \"string\") {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                code: null,\n                output: null,\n                ast: null,\n                errors: [\n                    \"Invalid request: code is required and must be a string\"\n                ]\n            }, {\n                status: 400\n            });\n        }\n        const compileResult = compileJPlusPlus(code);\n        if (!compileResult.success) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                code: compileResult.code || null,\n                output: null,\n                ast: compileResult.ast || null,\n                errors: compileResult.errors || []\n            });\n        }\n        // Execute the compiled JavaScript and capture output\n        let output = \"\";\n        let executionErrors = [];\n        let originalConsoleLog;\n        const logs = [];\n        try {\n            // Capture console.log output\n            originalConsoleLog = console.log;\n            console.log = (...args)=>{\n                logs.push(args.map((arg)=>typeof arg === \"object\" ? JSON.stringify(arg) : String(arg)).join(\" \"));\n            };\n            const executeCode = new Function(compileResult.code);\n            executeCode();\n            output = logs.join(\"\\n\");\n        } catch (execError) {\n            executionErrors.push({\n                message: execError instanceof Error ? execError.message : \"Runtime error occurred\",\n                type: \"runtime\"\n            });\n        } finally{\n            if (originalConsoleLog) console.log = originalConsoleLog;\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: compileResult.success && executionErrors.length === 0,\n            code: compileResult.code || null,\n            output: output,\n            ast: compileResult.ast || null,\n            errors: [\n                ...compileResult.errors || [],\n                ...executionErrors\n            ]\n        });\n    } catch (error) {\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            code: null,\n            output: null,\n            ast: null,\n            errors: [\n                {\n                    message: error instanceof Error ? error.message : \"Unknown server error\",\n                    type: \"server\"\n                }\n            ]\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQzFCQyxRQUFRO21CQUFLRyxjQUFjSCxNQUFNLElBQUksRUFBRTttQkFBTUk7YUFBZ0I7UUFDL0Q7SUFFRixFQUFFLE9BQU9kLE9BQU87UUFDZCxPQUFPWixxREFBWUEsQ0FBQ2lCLElBQUksQ0FDdEI7WUFDRUUsU0FBUztZQUNURCxNQUFNO1lBQ05FLFFBQVE7WUFDUkMsS0FBSztZQUNMQyxRQUFRO2dCQUFDO29CQUNQVCxTQUFTRCxpQkFBaUI2QixRQUFRN0IsTUFBTUMsT0FBTyxHQUFHO29CQUNsRFUsTUFBTTtnQkFDUjthQUFFO1FBQ0osR0FDQTtZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2pwcC1pZGUvLi9hcHAvYXBpL2V4ZWN1dGUvcm91dGUuanM/ZmIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XHJcbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdtb2R1bGUnO1xyXG5pbXBvcnQgeyBmaWxlVVJMVG9QYXRoIH0gZnJvbSAndXJsJztcclxuaW1wb3J0IHsgZGlybmFtZSwgcmVzb2x2ZSB9IGZyb20gJ3BhdGgnO1xyXG4vLyBVc2UgY3JlYXRlUmVxdWlyZSB0byBsb2FkIENvbW1vbkpTIG1vZHVsZXMgaW4gRVMgbW9kdWxlIGNvbnRleHRcclxuY29uc3QgX19maWxlbmFtZSA9IGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKTtcclxuY29uc3QgX19kaXJuYW1lID0gZGlybmFtZShfX2ZpbGVuYW1lKTtcclxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcclxubGV0IGNvbXBpbGVKUGx1c1BsdXM7XHJcbnRyeSB7XHJcbiAgLy8gVXNlIGEgc3RhdGljIHBhdGggc28gV2VicGFjayBjYW4gcmVzb2x2ZSB0aGUgZGVwZW5kZW5jeSBhdCBidWlsZCB0aW1lXHJcbiAgY29tcGlsZUpQbHVzUGx1cyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9qcHAvY29tcGlsZXIuanMnKTtcclxufSBjYXRjaCAoZSkge1xyXG4gIC8vIElmIGxvYWRpbmcgZmFpbHMgaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudCwgbG9nIGFuZCBrZWVwIG51bGwgc28gd2UgY2FuIHJldHVybiBhIDUwMCBhdCByZXF1ZXN0IHRpbWVcclxuICBjb21waWxlSlBsdXNQbHVzID0gbnVsbDtcclxuICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBKKysgY29tcGlsZXI6JywgZSAmJiBlLm1lc3NhZ2UgPyBlLm1lc3NhZ2UgOiBlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBPU1QgL2FwaS9leGVjdXRlXHJcbiAqIEV4ZWN1dGVzIEorKyBjb2RlIHNlcnZlci1zaWRlXHJcbiAqIFxyXG4gKiBSZXF1ZXN0IGJvZHk6IHsgY29kZTogc3RyaW5nIH1cclxuICogUmVzcG9uc2U6IHsgc3VjY2VzczogYm9vbGVhbiwgb3V0cHV0OiBzdHJpbmcsIGFzdDogb2JqZWN0LCBlcnJvcnM6IGFycmF5IH1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xyXG4gICAgY29uc3QgeyBjb2RlIH0gPSBib2R5O1xyXG5cclxuICAgIGlmICghY29tcGlsZUpQbHVzUGx1cykge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBjb2RlOiBudWxsLFxyXG4gICAgICAgICAgb3V0cHV0OiBudWxsLFxyXG4gICAgICAgICAgYXN0OiBudWxsLFxyXG4gICAgICAgICAgZXJyb3JzOiBbeyBtZXNzYWdlOiAnU2VydmVyIGVycm9yOiBjb21waWxlciBub3QgYXZhaWxhYmxlJywgdHlwZTogJ3NlcnZlcicgfV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29kZSB8fCB0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgY29kZTogbnVsbCxcclxuICAgICAgICAgIG91dHB1dDogbnVsbCxcclxuICAgICAgICAgIGFzdDogbnVsbCxcclxuICAgICAgICAgIGVycm9yczogWydJbnZhbGlkIHJlcXVlc3Q6IGNvZGUgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcnXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21waWxlUmVzdWx0ID0gY29tcGlsZUpQbHVzUGx1cyhjb2RlKTtcclxuICAgIGlmICghY29tcGlsZVJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgY29kZTogY29tcGlsZVJlc3VsdC5jb2RlIHx8IG51bGwsXHJcbiAgICAgICAgb3V0cHV0OiBudWxsLFxyXG4gICAgICAgIGFzdDogY29tcGlsZVJlc3VsdC5hc3QgfHwgbnVsbCxcclxuICAgICAgICBlcnJvcnM6IGNvbXBpbGVSZXN1bHQuZXJyb3JzIHx8IFtdXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gRXhlY3V0ZSB0aGUgY29tcGlsZWQgSmF2YVNjcmlwdCBhbmQgY2FwdHVyZSBvdXRwdXRcclxuICAgIGxldCBvdXRwdXQgPSAnJztcclxuICAgIGxldCBleGVjdXRpb25FcnJvcnMgPSBbXTtcclxuICAgIGxldCBvcmlnaW5hbENvbnNvbGVMb2c7XHJcbiAgICBjb25zdCBsb2dzID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDYXB0dXJlIGNvbnNvbGUubG9nIG91dHB1dFxyXG4gICAgICBvcmlnaW5hbENvbnNvbGVMb2cgPSBjb25zb2xlLmxvZztcclxuICAgICAgY29uc29sZS5sb2cgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGxvZ3MucHVzaChhcmdzLm1hcChhcmcgPT4gXHJcbiAgICAgICAgICB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGFyZykgOiBTdHJpbmcoYXJnKVxyXG4gICAgICAgICkuam9pbignICcpKTtcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgZXhlY3V0ZUNvZGUgPSBuZXcgRnVuY3Rpb24oY29tcGlsZVJlc3VsdC5jb2RlKTtcclxuICAgICAgZXhlY3V0ZUNvZGUoKTtcclxuICAgICAgb3V0cHV0ID0gbG9ncy5qb2luKCdcXG4nKTtcclxuICAgIH0gY2F0Y2ggKGV4ZWNFcnJvcikge1xyXG4gICAgICBleGVjdXRpb25FcnJvcnMucHVzaCh7XHJcbiAgICAgICAgbWVzc2FnZTogZXhlY0Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBleGVjRXJyb3IubWVzc2FnZSA6ICdSdW50aW1lIGVycm9yIG9jY3VycmVkJyxcclxuICAgICAgICB0eXBlOiAncnVudGltZSdcclxuICAgICAgfSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpZiAob3JpZ2luYWxDb25zb2xlTG9nKSBjb25zb2xlLmxvZyA9IG9yaWdpbmFsQ29uc29sZUxvZztcclxuICAgIH1cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgIHN1Y2Nlc3M6IGNvbXBpbGVSZXN1bHQuc3VjY2VzcyAmJiBleGVjdXRpb25FcnJvcnMubGVuZ3RoID09PSAwLFxyXG4gICAgICBjb2RlOiBjb21waWxlUmVzdWx0LmNvZGUgfHwgbnVsbCxcclxuICAgICAgb3V0cHV0OiBvdXRwdXQsXHJcbiAgICAgIGFzdDogY29tcGlsZVJlc3VsdC5hc3QgfHwgbnVsbCxcclxuICAgICAgZXJyb3JzOiBbLi4uKGNvbXBpbGVSZXN1bHQuZXJyb3JzIHx8IFtdKSwgLi4uZXhlY3V0aW9uRXJyb3JzXVxyXG4gICAgfSk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBjb2RlOiBudWxsLFxyXG4gICAgICAgIG91dHB1dDogbnVsbCxcclxuICAgICAgICBhc3Q6IG51bGwsXHJcbiAgICAgICAgZXJyb3JzOiBbe1xyXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBzZXJ2ZXIgZXJyb3InLFxyXG4gICAgICAgICAgdHlwZTogJ3NlcnZlcidcclxuICAgICAgICB9XVxyXG4gICAgICB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJjcmVhdGVSZXF1aXJlIiwiZmlsZVVSTFRvUGF0aCIsImRpcm5hbWUiLCJyZXNvbHZlIiwiX19maWxlbmFtZSIsInVybCIsIl9fZGlybmFtZSIsInJlcXVpcmUiLCJjb21waWxlSlBsdXNQbHVzIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIm1lc3NhZ2UiLCJQT1NUIiwicmVxdWVzdCIsImJvZHkiLCJqc29uIiwiY29kZSIsInN1Y2Nlc3MiLCJvdXRwdXQiLCJhc3QiLCJlcnJvcnMiLCJ0eXBlIiwic3RhdHVzIiwiY29tcGlsZVJlc3VsdCIsImV4ZWN1dGlvbkVycm9ycyIsIm9yaWdpbmFsQ29uc29sZUxvZyIsImxvZ3MiLCJsb2ciLCJhcmdzIiwicHVzaCIsIm1hcCIsImFyZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJqb2luIiwiZXhlY3V0ZUNvZGUiLCJGdW5jdGlvbiIsImV4ZWNFcnJvciIsIkVycm9yIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/execute/route.js\n");

/***/ }),

/***/ "(rsc)/./lib/jpp/compiler.js":
/*!*****************************!*\
  !*** ./lib/jpp/compiler.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * J++ Compiler - Full compilation pipeline with strict type checking\r\n * Lex → Parse → Type Check → Generate → Execute\r\n *\r\n * CORE FEATURE: Strict operator separation\r\n * - + is numeric-only (no coercion)\r\n * - . is string-only (no coercion)\r\n */ \nconst lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/./lib/jpp/lexer.js\");\nconst parser = __webpack_require__(/*! ./parser.js */ \"(rsc)/./lib/jpp/parser.js\");\nconst generate = __webpack_require__(/*! ./generator.js */ \"(rsc)/./lib/jpp/generator.js\");\nconst TypeChecker = __webpack_require__(/*! ./typeChecker.js */ \"(rsc)/./lib/jpp/typeChecker.js\");\n/**\r\n * Perform type-checking on the AST  \r\n */ function typeCheck(ast, typeChecker) {\n    for (const stmt of ast.body){\n        switch(stmt.type){\n            case \"Declaration\":\n                if (stmt.value) {\n                    typeChecker.checkExpression(stmt.value);\n                }\n                typeChecker.checkDeclaration(stmt.name, stmt.value);\n                break;\n            case \"Assignment\":\n                typeChecker.checkAssignment(stmt.name, stmt.value);\n                break;\n            case \"PrintStatement\":\n                typeChecker.checkExpression(stmt.value);\n                break;\n            case \"IfStatement\":\n                typeChecker.checkExpression(stmt.condition.left);\n                typeChecker.checkExpression(stmt.condition.right);\n                for (const bodyStmt of stmt.body){\n                    typeCheck({\n                        type: \"Program\",\n                        body: [\n                            bodyStmt\n                        ]\n                    }, typeChecker);\n                }\n                for (const elif of stmt.elseIf){\n                    typeChecker.checkExpression(elif.condition.left);\n                    typeChecker.checkExpression(elif.condition.right);\n                    for (const bodyStmt of elif.body){\n                        typeCheck({\n                            type: \"Program\",\n                            body: [\n                                bodyStmt\n                            ]\n                        }, typeChecker);\n                    }\n                }\n                if (stmt.elseBody) {\n                    for (const bodyStmt of stmt.elseBody){\n                        typeCheck({\n                            type: \"Program\",\n                            body: [\n                                bodyStmt\n                            ]\n                        }, typeChecker);\n                    }\n                }\n                break;\n            case \"WhileStatement\":\n                typeChecker.checkExpression(stmt.condition.left);\n                typeChecker.checkExpression(stmt.condition.right);\n                for (const bodyStmt of stmt.body){\n                    typeCheck({\n                        type: \"Program\",\n                        body: [\n                            bodyStmt\n                        ]\n                    }, typeChecker);\n                }\n                break;\n            case \"ForStatement\":\n                const prevScope = typeChecker.createScope();\n                typeChecker.checkExpression(stmt.start);\n                typeChecker.checkExpression(stmt.end);\n                typeChecker.symbols.set(stmt.variable, \"number\");\n                for (const bodyStmt of stmt.body){\n                    typeCheck({\n                        type: \"Program\",\n                        body: [\n                            bodyStmt\n                        ]\n                    }, typeChecker);\n                }\n                typeChecker.restoreScope(prevScope);\n                break;\n            case \"BreakStatement\":\n            case \"ContinueStatement\":\n                break;\n            default:\n                throw new Error(`Unknown statement type: ${stmt.type}`);\n        }\n    }\n}\n/**\r\n * COMPILE FUNCTION (CommonJS Export)\r\n */ function compileJPlusPlus(source) {\n    try {\n        const tokens = lexer(source);\n        const ast = parser(tokens);\n        const typeChecker = new TypeChecker();\n        typeCheck(ast, typeChecker);\n        const jsCode = generate(ast);\n        return {\n            success: true,\n            code: jsCode,\n            ast: ast,\n            errors: []\n        };\n    } catch (error) {\n        return {\n            success: false,\n            code: null,\n            ast: null,\n            errors: [\n                {\n                    message: error instanceof Error ? error.message : \"Unknown compilation error\",\n                    type: \"error\"\n                }\n            ]\n        };\n    }\n}\nmodule.exports = compileJPlusPlus;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUMxRDtJQUNGO0FBQ0Y7QUFDQTs7Q0FFQyxHQUNELFNBQVNzQixpQkFBaUJDLE1BQU07SUFDOUIsSUFBSTtRQUNGLE1BQU1DLFNBQVNsQyxNQUFNaUM7UUFDckIsTUFBTTNCLE1BQU1KLE9BQU9nQztRQUNuQixNQUFNM0IsY0FBYyxJQUFJSDtRQUN4QkMsVUFBVUMsS0FBS0M7UUFDZixNQUFNNEIsU0FBU2hDLFNBQVNHO1FBQ3hCLE9BQU87WUFDTDhCLFNBQVM7WUFDVEMsTUFBTUY7WUFDTjdCLEtBQUtBO1lBQ0xnQyxRQUFRLEVBQUU7UUFDWjtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkLE9BQU87WUFDTEgsU0FBUztZQUNUQyxNQUFNO1lBQ04vQixLQUFLO1lBQ0xnQyxRQUFRO2dCQUFDO29CQUNQRSxTQUFTRCxpQkFBaUJSLFFBQVFRLE1BQU1DLE9BQU8sR0FBRztvQkFDbEQ5QixNQUFNO2dCQUNSO2FBQUU7UUFDSjtJQUNGO0FBQ0Y7QUFDQStCLE9BQU9DLE9BQU8sR0FBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcHAtaWRlLy4vbGliL2pwcC9jb21waWxlci5qcz9lZGUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBKKysgQ29tcGlsZXIgLSBGdWxsIGNvbXBpbGF0aW9uIHBpcGVsaW5lIHdpdGggc3RyaWN0IHR5cGUgY2hlY2tpbmdcclxuICogTGV4IOKGkiBQYXJzZSDihpIgVHlwZSBDaGVjayDihpIgR2VuZXJhdGUg4oaSIEV4ZWN1dGVcclxuICpcclxuICogQ09SRSBGRUFUVVJFOiBTdHJpY3Qgb3BlcmF0b3Igc2VwYXJhdGlvblxyXG4gKiAtICsgaXMgbnVtZXJpYy1vbmx5IChubyBjb2VyY2lvbilcclxuICogLSAuIGlzIHN0cmluZy1vbmx5IChubyBjb2VyY2lvbilcclxuICovXHJcbmNvbnN0IGxleGVyID0gcmVxdWlyZSgnLi9sZXhlci5qcycpO1xyXG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlci5qcycpO1xyXG5jb25zdCBnZW5lcmF0ZSA9IHJlcXVpcmUoJy4vZ2VuZXJhdG9yLmpzJyk7XHJcbmNvbnN0IFR5cGVDaGVja2VyID0gcmVxdWlyZSgnLi90eXBlQ2hlY2tlci5qcycpO1xyXG4vKipcclxuICogUGVyZm9ybSB0eXBlLWNoZWNraW5nIG9uIHRoZSBBU1QgIFxyXG4gKi9cclxuZnVuY3Rpb24gdHlwZUNoZWNrKGFzdCwgdHlwZUNoZWNrZXIpIHtcclxuICBmb3IgKGNvbnN0IHN0bXQgb2YgYXN0LmJvZHkpIHtcclxuICAgIHN3aXRjaCAoc3RtdC50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ0RlY2xhcmF0aW9uJzpcclxuICAgICAgICBpZiAoc3RtdC52YWx1ZSkge1xyXG4gICAgICAgICAgdHlwZUNoZWNrZXIuY2hlY2tFeHByZXNzaW9uKHN0bXQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0eXBlQ2hlY2tlci5jaGVja0RlY2xhcmF0aW9uKHN0bXQubmFtZSwgc3RtdC52YWx1ZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0Fzc2lnbm1lbnQnOlxyXG4gICAgICAgIHR5cGVDaGVja2VyLmNoZWNrQXNzaWdubWVudChzdG10Lm5hbWUsIHN0bXQudmFsdWUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnUHJpbnRTdGF0ZW1lbnQnOlxyXG4gICAgICAgIHR5cGVDaGVja2VyLmNoZWNrRXhwcmVzc2lvbihzdG10LnZhbHVlKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxyXG4gICAgICAgIHR5cGVDaGVja2VyLmNoZWNrRXhwcmVzc2lvbihzdG10LmNvbmRpdGlvbi5sZWZ0KTtcclxuICAgICAgICB0eXBlQ2hlY2tlci5jaGVja0V4cHJlc3Npb24oc3RtdC5jb25kaXRpb24ucmlnaHQpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYm9keVN0bXQgb2Ygc3RtdC5ib2R5KSB7XHJcbiAgICAgICAgICB0eXBlQ2hlY2soeyB0eXBlOiAnUHJvZ3JhbScsIGJvZHk6IFtib2R5U3RtdF0gfSwgdHlwZUNoZWNrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGVsaWYgb2Ygc3RtdC5lbHNlSWYpIHtcclxuICAgICAgICAgIHR5cGVDaGVja2VyLmNoZWNrRXhwcmVzc2lvbihlbGlmLmNvbmRpdGlvbi5sZWZ0KTtcclxuICAgICAgICAgIHR5cGVDaGVja2VyLmNoZWNrRXhwcmVzc2lvbihlbGlmLmNvbmRpdGlvbi5yaWdodCk7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGJvZHlTdG10IG9mIGVsaWYuYm9keSkge1xyXG4gICAgICAgICAgICB0eXBlQ2hlY2soeyB0eXBlOiAnUHJvZ3JhbScsIGJvZHk6IFtib2R5U3RtdF0gfSwgdHlwZUNoZWNrZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RtdC5lbHNlQm9keSkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBib2R5U3RtdCBvZiBzdG10LmVsc2VCb2R5KSB7XHJcbiAgICAgICAgICAgIHR5cGVDaGVjayh7IHR5cGU6ICdQcm9ncmFtJywgYm9keTogW2JvZHlTdG10XSB9LCB0eXBlQ2hlY2tlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxyXG4gICAgICAgIHR5cGVDaGVja2VyLmNoZWNrRXhwcmVzc2lvbihzdG10LmNvbmRpdGlvbi5sZWZ0KTtcclxuICAgICAgICB0eXBlQ2hlY2tlci5jaGVja0V4cHJlc3Npb24oc3RtdC5jb25kaXRpb24ucmlnaHQpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGJvZHlTdG10IG9mIHN0bXQuYm9keSkge1xyXG4gICAgICAgICAgdHlwZUNoZWNrKHsgdHlwZTogJ1Byb2dyYW0nLCBib2R5OiBbYm9keVN0bXRdIH0sIHR5cGVDaGVja2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XHJcbiAgICAgICAgY29uc3QgcHJldlNjb3BlID0gdHlwZUNoZWNrZXIuY3JlYXRlU2NvcGUoKTtcclxuICAgICAgICB0eXBlQ2hlY2tlci5jaGVja0V4cHJlc3Npb24oc3RtdC5zdGFydCk7XHJcbiAgICAgICAgdHlwZUNoZWNrZXIuY2hlY2tFeHByZXNzaW9uKHN0bXQuZW5kKTtcclxuICAgICAgICB0eXBlQ2hlY2tlci5zeW1ib2xzLnNldChzdG10LnZhcmlhYmxlLCAnbnVtYmVyJyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBib2R5U3RtdCBvZiBzdG10LmJvZHkpIHtcclxuICAgICAgICAgIHR5cGVDaGVjayh7IHR5cGU6ICdQcm9ncmFtJywgYm9keTogW2JvZHlTdG10XSB9LCB0eXBlQ2hlY2tlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGVDaGVja2VyLnJlc3RvcmVTY29wZShwcmV2U2NvcGUpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XHJcbiAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RhdGVtZW50IHR5cGU6ICR7c3RtdC50eXBlfWApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKipcclxuICogQ09NUElMRSBGVU5DVElPTiAoQ29tbW9uSlMgRXhwb3J0KVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGlsZUpQbHVzUGx1cyhzb3VyY2UpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgdG9rZW5zID0gbGV4ZXIoc291cmNlKTtcclxuICAgIGNvbnN0IGFzdCA9IHBhcnNlcih0b2tlbnMpO1xyXG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSBuZXcgVHlwZUNoZWNrZXIoKTtcclxuICAgIHR5cGVDaGVjayhhc3QsIHR5cGVDaGVja2VyKTtcclxuICAgIGNvbnN0IGpzQ29kZSA9IGdlbmVyYXRlKGFzdCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBjb2RlOiBqc0NvZGUsXHJcbiAgICAgIGFzdDogYXN0LFxyXG4gICAgICBlcnJvcnM6IFtdXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgY29kZTogbnVsbCxcclxuICAgICAgYXN0OiBudWxsLFxyXG4gICAgICBlcnJvcnM6IFt7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBjb21waWxhdGlvbiBlcnJvcicsXHJcbiAgICAgICAgdHlwZTogJ2Vycm9yJ1xyXG4gICAgICB9XVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlSlBsdXNQbHVzO1xyXG4iXSwibmFtZXMiOlsibGV4ZXIiLCJyZXF1aXJlIiwicGFyc2VyIiwiZ2VuZXJhdGUiLCJUeXBlQ2hlY2tlciIsInR5cGVDaGVjayIsImFzdCIsInR5cGVDaGVja2VyIiwic3RtdCIsImJvZHkiLCJ0eXBlIiwidmFsdWUiLCJjaGVja0V4cHJlc3Npb24iLCJjaGVja0RlY2xhcmF0aW9uIiwibmFtZSIsImNoZWNrQXNzaWdubWVudCIsImNvbmRpdGlvbiIsImxlZnQiLCJyaWdodCIsImJvZHlTdG10IiwiZWxpZiIsImVsc2VJZiIsImVsc2VCb2R5IiwicHJldlNjb3BlIiwiY3JlYXRlU2NvcGUiLCJzdGFydCIsImVuZCIsInN5bWJvbHMiLCJzZXQiLCJ2YXJpYWJsZSIsInJlc3RvcmVTY29wZSIsIkVycm9yIiwiY29tcGlsZUpQbHVzUGx1cyIsInNvdXJjZSIsInRva2VucyIsImpzQ29kZSIsInN1Y2Nlc3MiLCJjb2RlIiwiZXJyb3JzIiwiZXJyb3IiLCJtZXNzYWdlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/jpp/compiler.js\n");

/***/ }),

/***/ "(rsc)/./lib/jpp/generator.js":
/*!******************************!*\
  !*** ./lib/jpp/generator.js ***!
  \******************************/
/***/ ((module) => {

eval("/**\r\n * J++ Code Generator - Converts AST to JavaScript\r\n * \r\n * STRICT OPERATOR GENERATION:\r\n * - + generates: (left + right) - but type checker ensures both are numbers\r\n * - . generates: (String(left) + String(right)) - but type checker ensures both are strings\r\n */ \nfunction generate(node) {\n    switch(node.type){\n        case \"Program\":\n            return node.body.map(generate).join(\"\\n\");\n        case \"Declaration\":\n            return `let ${node.name} = ${generateValue(node.value)};`;\n        case \"Assignment\":\n            return `${node.name} = ${generateValue(node.value)};`;\n        case \"PrintStatement\":\n            return `console.log(${generateValue(node.value)});`;\n        case \"IfStatement\":\n            let ifCode = `if (${generateCondition(node.condition)}) {\\n  ${node.body.map(generate).join(\"\\n  \")}\\n}`;\n            if (node.elseIf && node.elseIf.length > 0) {\n                for (let elseIfBlock of node.elseIf){\n                    ifCode += ` else if (${generateCondition(elseIfBlock.condition)}) {\\n  ${elseIfBlock.body.map(generate).join(\"\\n  \")}\\n}`;\n                }\n            }\n            if (node.elseBody && node.elseBody.length > 0) {\n                ifCode += ` else {\\n  ${node.elseBody.map(generate).join(\"\\n  \")}\\n}`;\n            }\n            return ifCode;\n        case \"WhileStatement\":\n            return `while (${generateCondition(node.condition)}) {\\n  ${node.body.map(generate).join(\"\\n  \")}\\n}`;\n        case \"ForStatement\":\n            return `for (let ${node.variable} = ${generateValue(node.start)}; ${node.variable} < ${generateValue(node.end)}; ${node.variable}++) {\\n  ${node.body.map(generate).join(\"\\n  \")}\\n}`;\n        case \"BreakStatement\":\n            return \"break;\";\n        case \"ContinueStatement\":\n            return \"continue;\";\n        default:\n            throw new Error(`Unknown node type: ${node.type}`);\n    }\n}\nfunction generateValue(node) {\n    if (node === null || node === undefined) {\n        return \"0\";\n    }\n    if (typeof node === \"number\") {\n        return String(node);\n    }\n    if (typeof node === \"string\") {\n        return `\"${node}\"`;\n    }\n    switch(node.type){\n        case \"Number\":\n            return String(node.value);\n        case \"String\":\n            const escaped = node.value.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\t/g, \"\\\\t\");\n            return `\"${escaped}\"`;\n        case \"Identifier\":\n            return node.value;\n        case \"BinaryOp\":\n            // +, -, *, / - all numeric operations\n            // Type checker ensures operands are numbers\n            return `(${generateValue(node.left)} ${node.operator} ${generateValue(node.right)})`;\n        case \"ConcatOp\":\n            // . operator - string concatenation\n            // Type checker ensures operands are strings\n            // Generate: (String(left) + String(right))\n            // Note: Since type checker guarantees strings, we can use direct + in JS\n            return `(${generateValue(node.left)} + ${generateValue(node.right)})`;\n        default:\n            throw new Error(`Cannot generate code for node type: ${node.type}`);\n    }\n}\nfunction generateCondition(condition) {\n    return `${generateValue(condition.left)} ${condition.operator} ${generateValue(condition.right)}`;\n}\nmodule.exports = generate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQ2ZBLE9BQU8sQ0FBQyxNQUFNLE9BQ2RBLE9BQU8sQ0FBQyxPQUFPLE9BQ2ZBLE9BQU8sQ0FBQyxPQUFPO1lBQ2xCLE9BQU8sQ0FBQyxDQUFDLEVBQUVELFFBQVEsQ0FBQyxDQUFDO1FBQ3ZCLEtBQUs7WUFDSCxPQUFPckIsS0FBS08sS0FBSztRQUNuQixLQUFLO1lBQ0gsc0NBQXNDO1lBQ3RDLDRDQUE0QztZQUM1QyxPQUFPLENBQUMsQ0FBQyxFQUFFRCxjQUFjTixLQUFLdUIsSUFBSSxFQUFFLENBQUMsRUFBRXZCLEtBQUt3QixRQUFRLENBQUMsQ0FBQyxFQUFFbEIsY0FBY04sS0FBS3lCLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDdEYsS0FBSztZQUNILG9DQUFvQztZQUNwQyw0Q0FBNEM7WUFDNUMsMkNBQTJDO1lBQzNDLHlFQUF5RTtZQUN6RSxPQUFPLENBQUMsQ0FBQyxFQUFFbkIsY0FBY04sS0FBS3VCLElBQUksRUFBRSxHQUFHLEVBQUVqQixjQUFjTixLQUFLeUIsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN2RTtZQUNFLE1BQU0sSUFBSVAsTUFBTSxDQUFDLG9DQUFvQyxFQUFFbEIsS0FBS0MsSUFBSSxDQUFDLENBQUM7SUFDdEU7QUFDRjtBQUNBLFNBQVNRLGtCQUFrQkMsU0FBUztJQUNsQyxPQUFPLENBQUMsRUFBRUosY0FBY0ksVUFBVWEsSUFBSSxFQUFFLENBQUMsRUFBRWIsVUFBVWMsUUFBUSxDQUFDLENBQUMsRUFBRWxCLGNBQWNJLFVBQVVlLEtBQUssRUFBRSxDQUFDO0FBQ25HO0FBQ0FDLE9BQU9DLE9BQU8sR0FBRzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanBwLWlkZS8uL2xpYi9qcHAvZ2VuZXJhdG9yLmpzPzI5M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEorKyBDb2RlIEdlbmVyYXRvciAtIENvbnZlcnRzIEFTVCB0byBKYXZhU2NyaXB0XHJcbiAqIFxyXG4gKiBTVFJJQ1QgT1BFUkFUT1IgR0VORVJBVElPTjpcclxuICogLSArIGdlbmVyYXRlczogKGxlZnQgKyByaWdodCkgLSBidXQgdHlwZSBjaGVja2VyIGVuc3VyZXMgYm90aCBhcmUgbnVtYmVyc1xyXG4gKiAtIC4gZ2VuZXJhdGVzOiAoU3RyaW5nKGxlZnQpICsgU3RyaW5nKHJpZ2h0KSkgLSBidXQgdHlwZSBjaGVja2VyIGVuc3VyZXMgYm90aCBhcmUgc3RyaW5nc1xyXG4gKi9cclxuIGZ1bmN0aW9uIGdlbmVyYXRlKG5vZGUpIHtcclxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgY2FzZSAnUHJvZ3JhbSc6XHJcbiAgICAgIHJldHVybiBub2RlLmJvZHkubWFwKGdlbmVyYXRlKS5qb2luKCdcXG4nKTtcclxuICAgIGNhc2UgJ0RlY2xhcmF0aW9uJzpcclxuICAgICAgcmV0dXJuIGBsZXQgJHtub2RlLm5hbWV9ID0gJHtnZW5lcmF0ZVZhbHVlKG5vZGUudmFsdWUpfTtgO1xyXG4gICAgY2FzZSAnQXNzaWdubWVudCc6XHJcbiAgICAgIHJldHVybiBgJHtub2RlLm5hbWV9ID0gJHtnZW5lcmF0ZVZhbHVlKG5vZGUudmFsdWUpfTtgO1xyXG4gICAgY2FzZSAnUHJpbnRTdGF0ZW1lbnQnOlxyXG4gICAgICByZXR1cm4gYGNvbnNvbGUubG9nKCR7Z2VuZXJhdGVWYWx1ZShub2RlLnZhbHVlKX0pO2A7XHJcbiAgICBjYXNlICdJZlN0YXRlbWVudCc6XHJcbiAgICAgIGxldCBpZkNvZGUgPSBgaWYgKCR7Z2VuZXJhdGVDb25kaXRpb24obm9kZS5jb25kaXRpb24pfSkge1xcbiAgJHtub2RlLmJvZHkubWFwKGdlbmVyYXRlKS5qb2luKCdcXG4gICcpfVxcbn1gO1xyXG4gICAgICBpZiAobm9kZS5lbHNlSWYgJiYgbm9kZS5lbHNlSWYubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGVsc2VJZkJsb2NrIG9mIG5vZGUuZWxzZUlmKSB7XHJcbiAgICAgICAgICBpZkNvZGUgKz0gYCBlbHNlIGlmICgke2dlbmVyYXRlQ29uZGl0aW9uKGVsc2VJZkJsb2NrLmNvbmRpdGlvbil9KSB7XFxuICAke2Vsc2VJZkJsb2NrLmJvZHkubWFwKGdlbmVyYXRlKS5qb2luKCdcXG4gICcpfVxcbn1gO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAobm9kZS5lbHNlQm9keSAmJiBub2RlLmVsc2VCb2R5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZkNvZGUgKz0gYCBlbHNlIHtcXG4gICR7bm9kZS5lbHNlQm9keS5tYXAoZ2VuZXJhdGUpLmpvaW4oJ1xcbiAgJyl9XFxufWA7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlmQ29kZTtcclxuICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcclxuICAgICAgcmV0dXJuIGB3aGlsZSAoJHtnZW5lcmF0ZUNvbmRpdGlvbihub2RlLmNvbmRpdGlvbil9KSB7XFxuICAke25vZGUuYm9keS5tYXAoZ2VuZXJhdGUpLmpvaW4oJ1xcbiAgJyl9XFxufWA7XHJcbiAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxyXG4gICAgICByZXR1cm4gYGZvciAobGV0ICR7bm9kZS52YXJpYWJsZX0gPSAke2dlbmVyYXRlVmFsdWUobm9kZS5zdGFydCl9OyAke25vZGUudmFyaWFibGV9IDwgJHtnZW5lcmF0ZVZhbHVlKG5vZGUuZW5kKX07ICR7bm9kZS52YXJpYWJsZX0rKykge1xcbiAgJHtub2RlLmJvZHkubWFwKGdlbmVyYXRlKS5qb2luKCdcXG4gICcpfVxcbn1gO1xyXG4gICAgY2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxyXG4gICAgICByZXR1cm4gJ2JyZWFrOyc7XHJcbiAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XHJcbiAgICAgIHJldHVybiAnY29udGludWU7JztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZW5lcmF0ZVZhbHVlKG5vZGUpIHtcclxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiAnMCc7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcclxuICAgIHJldHVybiBTdHJpbmcobm9kZSk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBgXCIke25vZGV9XCJgO1xyXG4gIH1cclxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgY2FzZSAnTnVtYmVyJzpcclxuICAgICAgcmV0dXJuIFN0cmluZyhub2RlLnZhbHVlKTtcclxuICAgIGNhc2UgJ1N0cmluZyc6XHJcbiAgICAgIGNvbnN0IGVzY2FwZWQgPSBub2RlLnZhbHVlXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcclxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jyk7XHJcbiAgICAgIHJldHVybiBgXCIke2VzY2FwZWR9XCJgO1xyXG4gICAgY2FzZSAnSWRlbnRpZmllcic6XHJcbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgY2FzZSAnQmluYXJ5T3AnOlxyXG4gICAgICAvLyArLCAtLCAqLCAvIC0gYWxsIG51bWVyaWMgb3BlcmF0aW9uc1xyXG4gICAgICAvLyBUeXBlIGNoZWNrZXIgZW5zdXJlcyBvcGVyYW5kcyBhcmUgbnVtYmVyc1xyXG4gICAgICByZXR1cm4gYCgke2dlbmVyYXRlVmFsdWUobm9kZS5sZWZ0KX0gJHtub2RlLm9wZXJhdG9yfSAke2dlbmVyYXRlVmFsdWUobm9kZS5yaWdodCl9KWA7XHJcbiAgICBjYXNlICdDb25jYXRPcCc6XHJcbiAgICAgIC8vIC4gb3BlcmF0b3IgLSBzdHJpbmcgY29uY2F0ZW5hdGlvblxyXG4gICAgICAvLyBUeXBlIGNoZWNrZXIgZW5zdXJlcyBvcGVyYW5kcyBhcmUgc3RyaW5nc1xyXG4gICAgICAvLyBHZW5lcmF0ZTogKFN0cmluZyhsZWZ0KSArIFN0cmluZyhyaWdodCkpXHJcbiAgICAgIC8vIE5vdGU6IFNpbmNlIHR5cGUgY2hlY2tlciBndWFyYW50ZWVzIHN0cmluZ3MsIHdlIGNhbiB1c2UgZGlyZWN0ICsgaW4gSlNcclxuICAgICAgcmV0dXJuIGAoJHtnZW5lcmF0ZVZhbHVlKG5vZGUubGVmdCl9ICsgJHtnZW5lcmF0ZVZhbHVlKG5vZGUucmlnaHQpfSlgO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2VuZXJhdGUgY29kZSBmb3Igbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVDb25kaXRpb24oY29uZGl0aW9uKSB7XHJcbiAgcmV0dXJuIGAke2dlbmVyYXRlVmFsdWUoY29uZGl0aW9uLmxlZnQpfSAke2NvbmRpdGlvbi5vcGVyYXRvcn0gJHtnZW5lcmF0ZVZhbHVlKGNvbmRpdGlvbi5yaWdodCl9YDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlOyJdLCJuYW1lcyI6WyJnZW5lcmF0ZSIsIm5vZGUiLCJ0eXBlIiwiYm9keSIsIm1hcCIsImpvaW4iLCJuYW1lIiwiZ2VuZXJhdGVWYWx1ZSIsInZhbHVlIiwiaWZDb2RlIiwiZ2VuZXJhdGVDb25kaXRpb24iLCJjb25kaXRpb24iLCJlbHNlSWYiLCJsZW5ndGgiLCJlbHNlSWZCbG9jayIsImVsc2VCb2R5IiwidmFyaWFibGUiLCJzdGFydCIsImVuZCIsIkVycm9yIiwidW5kZWZpbmVkIiwiU3RyaW5nIiwiZXNjYXBlZCIsInJlcGxhY2UiLCJsZWZ0Iiwib3BlcmF0b3IiLCJyaWdodCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/jpp/generator.js\n");

/***/ }),

/***/ "(rsc)/./lib/jpp/lexer.js":
/*!**************************!*\
  !*** ./lib/jpp/lexer.js ***!
  \**************************/
/***/ ((module) => {

eval("/**\r\n * J++ Lexer - Tokenizes J++ source code\r\n * \r\n * STRICT OPERATOR RULES:\r\n * - + is numeric-only addition\r\n * - . is string-only concatenation\r\n * - No implicit coercion\r\n */ \nfunction lexer(input) {\n    const tokens = [];\n    let cursor = 0;\n    while(cursor < input.length){\n        let char = input[cursor];\n        // Skip whitespace\n        if (/\\s/.test(char)) {\n            cursor++;\n            continue;\n        }\n        // Single-line comments\n        if (char === \"/\" && cursor + 1 < input.length && input[cursor + 1] === \"/\") {\n            while(cursor < input.length && input[cursor] !== \"\\n\"){\n                cursor++;\n            }\n            continue;\n        }\n        // Multi-line comments\n        if (char === \"/\" && cursor + 1 < input.length && input[cursor + 1] === \"*\") {\n            cursor += 2;\n            while(cursor + 1 < input.length && !(input[cursor] === \"*\" && input[cursor + 1] === \"/\")){\n                cursor++;\n            }\n            cursor += 2;\n            continue;\n        }\n        // String literals (double quotes)\n        if (char === '\"') {\n            cursor++; // Skip opening quote\n            let str = \"\";\n            while(cursor < input.length && input[cursor] !== '\"'){\n                if (input[cursor] === \"\\\\\" && cursor + 1 < input.length) {\n                    // Handle escape sequences\n                    cursor++;\n                    const next = input[cursor];\n                    if (next === \"n\") str += \"\\n\";\n                    else if (next === \"t\") str += \"\t\";\n                    else if (next === \"\\\\\") str += \"\\\\\";\n                    else if (next === '\"') str += '\"';\n                    else str += next;\n                    cursor++;\n                } else {\n                    str += input[cursor];\n                    cursor++;\n                }\n            }\n            if (cursor >= input.length) {\n                throw new Error(\"Unclosed string literal\");\n            }\n            cursor++; // Skip closing quote\n            tokens.push({\n                type: \"string\",\n                value: str\n            });\n            continue;\n        }\n        // String literals (single quotes)\n        if (char === \"'\") {\n            cursor++; // Skip opening quote\n            let str = \"\";\n            while(cursor < input.length && input[cursor] !== \"'\"){\n                if (input[cursor] === \"\\\\\" && cursor + 1 < input.length) {\n                    // Handle escape sequences\n                    cursor++;\n                    const next = input[cursor];\n                    if (next === \"n\") str += \"\\n\";\n                    else if (next === \"t\") str += \"\t\";\n                    else if (next === \"\\\\\") str += \"\\\\\";\n                    else if (next === \"'\") str += \"'\";\n                    else str += next;\n                    cursor++;\n                } else {\n                    str += input[cursor];\n                    cursor++;\n                }\n            }\n            if (cursor >= input.length) {\n                throw new Error(\"Unclosed string literal\");\n            }\n            cursor++; // Skip closing quote\n            tokens.push({\n                type: \"string\",\n                value: str\n            });\n            continue;\n        }\n        // Multi-word keywords\n        if (input.slice(cursor).startsWith(\"nahi agar\")) {\n            tokens.push({\n                type: \"keyword\",\n                value: \"nahi agar\"\n            });\n            cursor += \"nahi agar\".length;\n            continue;\n        }\n        if (input.slice(cursor).startsWith(\"ke liye\")) {\n            const after = cursor + \"ke liye\".length;\n            const boundaryOk = after >= input.length || !/[a-zA-Z0-9_]/.test(input[after]);\n            if (boundaryOk) {\n                tokens.push({\n                    type: \"keyword\",\n                    value: \"ke liye\"\n                });\n                cursor = after;\n                continue;\n            }\n        }\n        // Identifiers and keywords\n        if (/[a-zA-Z_]/.test(char)) {\n            let word = \"\";\n            while(cursor < input.length && /[a-zA-Z0-9_]/.test(input[cursor])){\n                word += input[cursor];\n                cursor++;\n            }\n            const keywords = [\n                \"ye\",\n                \"bol\",\n                \"agar\",\n                \"nahi\",\n                \"jabtak\",\n                \"tak\",\n                \"break\",\n                \"continue\"\n            ];\n            if (keywords.includes(word)) {\n                tokens.push({\n                    type: \"keyword\",\n                    value: word\n                });\n            } else {\n                tokens.push({\n                    type: \"identifier\",\n                    value: word\n                });\n            }\n            continue;\n        }\n        // Numbers\n        if (/[0-9]/.test(char)) {\n            let num = \"\";\n            while(cursor < input.length && /[0-9]/.test(input[cursor])){\n                num += input[cursor];\n                cursor++;\n            }\n            tokens.push({\n                type: \"number\",\n                value: num\n            });\n            continue;\n        }\n        // String concatenation operator (.) - MUST be checked before other operators\n        // to avoid conflicts with decimal numbers (handled above) and method calls (future)\n        if (char === \".\") {\n            // Ensure it's not part of a number (already handled above)\n            // Ensure it's not .. (future range operator)\n            if (cursor + 1 < input.length && input[cursor + 1] === \".\") {\n                throw new Error('Unexpected \"..\" operator (not yet supported)');\n            }\n            tokens.push({\n                type: \"operator\",\n                value: \".\"\n            });\n            cursor++;\n            continue;\n        }\n        // Operators\n        if (/[\\+\\-\\*\\/\\=\\<\\>\\!]/.test(char)) {\n            if (char === \"=\" && cursor + 1 < input.length && input[cursor + 1] === \"=\") {\n                tokens.push({\n                    type: \"operator\",\n                    value: \"==\"\n                });\n                cursor += 2;\n            } else if (char === \"<\" && cursor + 1 < input.length && input[cursor + 1] === \"=\") {\n                tokens.push({\n                    type: \"operator\",\n                    value: \"<=\"\n                });\n                cursor += 2;\n            } else if (char === \">\" && cursor + 1 < input.length && input[cursor + 1] === \"=\") {\n                tokens.push({\n                    type: \"operator\",\n                    value: \">=\"\n                });\n                cursor += 2;\n            } else if (char === \"!\" && cursor + 1 < input.length && input[cursor + 1] === \"=\") {\n                tokens.push({\n                    type: \"operator\",\n                    value: \"!=\"\n                });\n                cursor += 2;\n            } else {\n                tokens.push({\n                    type: \"operator\",\n                    value: char\n                });\n                cursor++;\n            }\n            continue;\n        }\n        // Braces\n        if (char === \"{\" || char === \"}\") {\n            tokens.push({\n                type: \"brace\",\n                value: char\n            });\n            cursor++;\n            continue;\n        }\n        // Parentheses\n        if (char === \"(\" || char === \")\") {\n            tokens.push({\n                type: \"paren\",\n                value: char\n            });\n            cursor++;\n            continue;\n        }\n        cursor++;\n    }\n    return tokens;\n}\nmodule.exports = lexer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVMsRUFBRSxLQUFLLEtBQUs7Z0JBQ2pGRCxPQUFPUSxJQUFJLENBQUM7b0JBQUVDLE1BQU07b0JBQVlDLE9BQU87Z0JBQUs7Z0JBQzVDVCxVQUFVO1lBQ1osT0FBTyxJQUFJRSxTQUFTLE9BQU9GLFNBQVMsSUFBSUYsTUFBTUcsTUFBTSxJQUFJSCxLQUFLLENBQUNFLFNBQVMsRUFBRSxLQUFLLEtBQUs7Z0JBQ2pGRCxPQUFPUSxJQUFJLENBQUM7b0JBQUVDLE1BQU07b0JBQVlDLE9BQU87Z0JBQUs7Z0JBQzVDVCxVQUFVO1lBQ1osT0FBTztnQkFDTEQsT0FBT1EsSUFBSSxDQUFDO29CQUFFQyxNQUFNO29CQUFZQyxPQUFPUDtnQkFBSztnQkFDNUNGO1lBQ0Y7WUFDQTtRQUNGO1FBRUEsU0FBUztRQUNULElBQUlFLFNBQVMsT0FBT0EsU0FBUyxLQUFLO1lBQ2hDSCxPQUFPUSxJQUFJLENBQUM7Z0JBQUVDLE1BQU07Z0JBQVNDLE9BQU9QO1lBQUs7WUFDekNGO1lBQ0E7UUFDRjtRQUVBLGNBQWM7UUFDZCxJQUFJRSxTQUFTLE9BQU9BLFNBQVMsS0FBSztZQUNoQ0gsT0FBT1EsSUFBSSxDQUFDO2dCQUFFQyxNQUFNO2dCQUFTQyxPQUFPUDtZQUFLO1lBQ3pDRjtZQUNBO1FBQ0Y7UUFFQUE7SUFDRjtJQUVBLE9BQU9EO0FBQ1Q7QUFDQW1CLE9BQU9DLE9BQU8sR0FBR3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanBwLWlkZS8uL2xpYi9qcHAvbGV4ZXIuanM/NTlkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSisrIExleGVyIC0gVG9rZW5pemVzIEorKyBzb3VyY2UgY29kZVxyXG4gKiBcclxuICogU1RSSUNUIE9QRVJBVE9SIFJVTEVTOlxyXG4gKiAtICsgaXMgbnVtZXJpYy1vbmx5IGFkZGl0aW9uXHJcbiAqIC0gLiBpcyBzdHJpbmctb25seSBjb25jYXRlbmF0aW9uXHJcbiAqIC0gTm8gaW1wbGljaXQgY29lcmNpb25cclxuICovXHJcblxyXG4gZnVuY3Rpb24gbGV4ZXIoaW5wdXQpIHtcclxuICBjb25zdCB0b2tlbnMgPSBbXTtcclxuICBsZXQgY3Vyc29yID0gMDtcclxuICBcclxuICB3aGlsZSAoY3Vyc29yIDwgaW5wdXQubGVuZ3RoKSB7XHJcbiAgICBsZXQgY2hhciA9IGlucHV0W2N1cnNvcl07XHJcbiAgICBcclxuICAgIC8vIFNraXAgd2hpdGVzcGFjZVxyXG4gICAgaWYgKC9cXHMvLnRlc3QoY2hhcikpIHtcclxuICAgICAgY3Vyc29yKys7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTaW5nbGUtbGluZSBjb21tZW50c1xyXG4gICAgaWYgKGNoYXIgPT09ICcvJyAmJiBjdXJzb3IgKyAxIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvciArIDFdID09PSAnLycpIHtcclxuICAgICAgd2hpbGUgKGN1cnNvciA8IGlucHV0Lmxlbmd0aCAmJiBpbnB1dFtjdXJzb3JdICE9PSAnXFxuJykge1xyXG4gICAgICAgIGN1cnNvcisrO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBNdWx0aS1saW5lIGNvbW1lbnRzXHJcbiAgICBpZiAoY2hhciA9PT0gJy8nICYmIGN1cnNvciArIDEgPCBpbnB1dC5sZW5ndGggJiYgaW5wdXRbY3Vyc29yICsgMV0gPT09ICcqJykge1xyXG4gICAgICBjdXJzb3IgKz0gMjtcclxuICAgICAgd2hpbGUgKGN1cnNvciArIDEgPCBpbnB1dC5sZW5ndGggJiYgIShpbnB1dFtjdXJzb3JdID09PSAnKicgJiYgaW5wdXRbY3Vyc29yICsgMV0gPT09ICcvJykpIHtcclxuICAgICAgICBjdXJzb3IrKztcclxuICAgICAgfVxyXG4gICAgICBjdXJzb3IgKz0gMjtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFN0cmluZyBsaXRlcmFscyAoZG91YmxlIHF1b3RlcylcclxuICAgIGlmIChjaGFyID09PSAnXCInKSB7XHJcbiAgICAgIGN1cnNvcisrOyAvLyBTa2lwIG9wZW5pbmcgcXVvdGVcclxuICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICB3aGlsZSAoY3Vyc29yIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvcl0gIT09ICdcIicpIHtcclxuICAgICAgICBpZiAoaW5wdXRbY3Vyc29yXSA9PT0gJ1xcXFwnICYmIGN1cnNvciArIDEgPCBpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgIC8vIEhhbmRsZSBlc2NhcGUgc2VxdWVuY2VzXHJcbiAgICAgICAgICBjdXJzb3IrKztcclxuICAgICAgICAgIGNvbnN0IG5leHQgPSBpbnB1dFtjdXJzb3JdO1xyXG4gICAgICAgICAgaWYgKG5leHQgPT09ICduJykgc3RyICs9ICdcXG4nO1xyXG4gICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ3QnKSBzdHIgKz0gJ1xcdCc7XHJcbiAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxcXCcpIHN0ciArPSAnXFxcXCc7XHJcbiAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXCInKSBzdHIgKz0gJ1wiJztcclxuICAgICAgICAgIGVsc2Ugc3RyICs9IG5leHQ7XHJcbiAgICAgICAgICBjdXJzb3IrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyICs9IGlucHV0W2N1cnNvcl07XHJcbiAgICAgICAgICBjdXJzb3IrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnNvciA+PSBpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHN0cmluZyBsaXRlcmFsJyk7XHJcbiAgICAgIH1cclxuICAgICAgY3Vyc29yKys7IC8vIFNraXAgY2xvc2luZyBxdW90ZVxyXG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogc3RyIH0pO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU3RyaW5nIGxpdGVyYWxzIChzaW5nbGUgcXVvdGVzKVxyXG4gICAgaWYgKGNoYXIgPT09IFwiJ1wiKSB7XHJcbiAgICAgIGN1cnNvcisrOyAvLyBTa2lwIG9wZW5pbmcgcXVvdGVcclxuICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICB3aGlsZSAoY3Vyc29yIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvcl0gIT09IFwiJ1wiKSB7XHJcbiAgICAgICAgaWYgKGlucHV0W2N1cnNvcl0gPT09ICdcXFxcJyAmJiBjdXJzb3IgKyAxIDwgaW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAvLyBIYW5kbGUgZXNjYXBlIHNlcXVlbmNlc1xyXG4gICAgICAgICAgY3Vyc29yKys7XHJcbiAgICAgICAgICBjb25zdCBuZXh0ID0gaW5wdXRbY3Vyc29yXTtcclxuICAgICAgICAgIGlmIChuZXh0ID09PSAnbicpIHN0ciArPSAnXFxuJztcclxuICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd0Jykgc3RyICs9ICdcXHQnO1xyXG4gICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1xcXFwnKSBzdHIgKz0gJ1xcXFwnO1xyXG4gICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gXCInXCIpIHN0ciArPSBcIidcIjtcclxuICAgICAgICAgIGVsc2Ugc3RyICs9IG5leHQ7XHJcbiAgICAgICAgICBjdXJzb3IrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyICs9IGlucHV0W2N1cnNvcl07XHJcbiAgICAgICAgICBjdXJzb3IrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnNvciA+PSBpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHN0cmluZyBsaXRlcmFsJyk7XHJcbiAgICAgIH1cclxuICAgICAgY3Vyc29yKys7IC8vIFNraXAgY2xvc2luZyBxdW90ZVxyXG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogc3RyIH0pO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTXVsdGktd29yZCBrZXl3b3Jkc1xyXG4gICAgaWYgKGlucHV0LnNsaWNlKGN1cnNvcikuc3RhcnRzV2l0aCgnbmFoaSBhZ2FyJykpIHtcclxuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAna2V5d29yZCcsIHZhbHVlOiAnbmFoaSBhZ2FyJyB9KTtcclxuICAgICAgY3Vyc29yICs9ICduYWhpIGFnYXInLmxlbmd0aDtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChpbnB1dC5zbGljZShjdXJzb3IpLnN0YXJ0c1dpdGgoJ2tlIGxpeWUnKSkge1xyXG4gICAgICBjb25zdCBhZnRlciA9IGN1cnNvciArICdrZSBsaXllJy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IGJvdW5kYXJ5T2sgPVxyXG4gICAgICAgIGFmdGVyID49IGlucHV0Lmxlbmd0aCB8fFxyXG4gICAgICAgICEvW2EtekEtWjAtOV9dLy50ZXN0KGlucHV0W2FmdGVyXSk7XHJcbiAgICAgIGlmIChib3VuZGFyeU9rKSB7XHJcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAna2V5d29yZCcsIHZhbHVlOiAna2UgbGl5ZScgfSk7XHJcbiAgICAgICAgY3Vyc29yID0gYWZ0ZXI7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSWRlbnRpZmllcnMgYW5kIGtleXdvcmRzXHJcbiAgICBpZiAoL1thLXpBLVpfXS8udGVzdChjaGFyKSkge1xyXG4gICAgICBsZXQgd29yZCA9ICcnO1xyXG4gICAgICB3aGlsZSAoY3Vyc29yIDwgaW5wdXQubGVuZ3RoICYmIC9bYS16QS1aMC05X10vLnRlc3QoaW5wdXRbY3Vyc29yXSkpIHtcclxuICAgICAgICB3b3JkICs9IGlucHV0W2N1cnNvcl07XHJcbiAgICAgICAgY3Vyc29yKys7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qga2V5d29yZHMgPSBbJ3llJywgJ2JvbCcsICdhZ2FyJywgJ25haGknLCAnamFidGFrJywgJ3RhaycsICdicmVhaycsICdjb250aW51ZSddO1xyXG4gICAgICBpZiAoa2V5d29yZHMuaW5jbHVkZXMod29yZCkpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdrZXl3b3JkJywgdmFsdWU6IHdvcmQgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnaWRlbnRpZmllcicsIHZhbHVlOiB3b3JkIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBOdW1iZXJzXHJcbiAgICBpZiAoL1swLTldLy50ZXN0KGNoYXIpKSB7XHJcbiAgICAgIGxldCBudW0gPSAnJztcclxuICAgICAgd2hpbGUgKGN1cnNvciA8IGlucHV0Lmxlbmd0aCAmJiAvWzAtOV0vLnRlc3QoaW5wdXRbY3Vyc29yXSkpIHtcclxuICAgICAgICBudW0gKz0gaW5wdXRbY3Vyc29yXTtcclxuICAgICAgICBjdXJzb3IrKztcclxuICAgICAgfVxyXG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdudW1iZXInLCB2YWx1ZTogbnVtIH0pO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU3RyaW5nIGNvbmNhdGVuYXRpb24gb3BlcmF0b3IgKC4pIC0gTVVTVCBiZSBjaGVja2VkIGJlZm9yZSBvdGhlciBvcGVyYXRvcnNcclxuICAgIC8vIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIGRlY2ltYWwgbnVtYmVycyAoaGFuZGxlZCBhYm92ZSkgYW5kIG1ldGhvZCBjYWxscyAoZnV0dXJlKVxyXG4gICAgaWYgKGNoYXIgPT09ICcuJykge1xyXG4gICAgICAvLyBFbnN1cmUgaXQncyBub3QgcGFydCBvZiBhIG51bWJlciAoYWxyZWFkeSBoYW5kbGVkIGFib3ZlKVxyXG4gICAgICAvLyBFbnN1cmUgaXQncyBub3QgLi4gKGZ1dHVyZSByYW5nZSBvcGVyYXRvcilcclxuICAgICAgaWYgKGN1cnNvciArIDEgPCBpbnB1dC5sZW5ndGggJiYgaW5wdXRbY3Vyc29yICsgMV0gPT09ICcuJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBcIi4uXCIgb3BlcmF0b3IgKG5vdCB5ZXQgc3VwcG9ydGVkKScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6ICcuJyB9KTtcclxuICAgICAgY3Vyc29yKys7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBPcGVyYXRvcnNcclxuICAgIGlmICgvW1xcK1xcLVxcKlxcL1xcPVxcPFxcPlxcIV0vLnRlc3QoY2hhcikpIHtcclxuICAgICAgaWYgKGNoYXIgPT09ICc9JyAmJiBjdXJzb3IgKyAxIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvciArIDFdID09PSAnPScpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnPT0nIH0pO1xyXG4gICAgICAgIGN1cnNvciArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc8JyAmJiBjdXJzb3IgKyAxIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvciArIDFdID09PSAnPScpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnPD0nIH0pO1xyXG4gICAgICAgIGN1cnNvciArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICc+JyAmJiBjdXJzb3IgKyAxIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvciArIDFdID09PSAnPScpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnPj0nIH0pO1xyXG4gICAgICAgIGN1cnNvciArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICchJyAmJiBjdXJzb3IgKyAxIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W2N1cnNvciArIDFdID09PSAnPScpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnIT0nIH0pO1xyXG4gICAgICAgIGN1cnNvciArPSAyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6IGNoYXIgfSk7XHJcbiAgICAgICAgY3Vyc29yKys7XHJcbiAgICAgIH1cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEJyYWNlc1xyXG4gICAgaWYgKGNoYXIgPT09ICd7JyB8fCBjaGFyID09PSAnfScpIHtcclxuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAnYnJhY2UnLCB2YWx1ZTogY2hhciB9KTtcclxuICAgICAgY3Vyc29yKys7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBQYXJlbnRoZXNlc1xyXG4gICAgaWYgKGNoYXIgPT09ICcoJyB8fCBjaGFyID09PSAnKScpIHtcclxuICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiAncGFyZW4nLCB2YWx1ZTogY2hhciB9KTtcclxuICAgICAgY3Vyc29yKys7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjdXJzb3IrKztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHRva2VucztcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGxleGVyOyJdLCJuYW1lcyI6WyJsZXhlciIsImlucHV0IiwidG9rZW5zIiwiY3Vyc29yIiwibGVuZ3RoIiwiY2hhciIsInRlc3QiLCJzdHIiLCJuZXh0IiwiRXJyb3IiLCJwdXNoIiwidHlwZSIsInZhbHVlIiwic2xpY2UiLCJzdGFydHNXaXRoIiwiYWZ0ZXIiLCJib3VuZGFyeU9rIiwid29yZCIsImtleXdvcmRzIiwiaW5jbHVkZXMiLCJudW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/jpp/lexer.js\n");

/***/ }),

/***/ "(rsc)/./lib/jpp/parser.js":
/*!***************************!*\
  !*** ./lib/jpp/parser.js ***!
  \***************************/
/***/ ((module) => {

eval("/**\r\n * J++ Parser - Builds AST from tokens\r\n * \r\n * OPERATOR PRECEDENCE (highest to lowest):\r\n * 1. Primary (numbers, strings, identifiers, parentheses)\r\n * 2. Multiplicative (*, /)\r\n * 3. Concatenation (.) - NEW: string-only\r\n * 4. Additive (+, -) - numeric-only\r\n */ \nfunction parser(tokens) {\n    const ast = {\n        type: \"Program\",\n        body: []\n    };\n    const tokenCopy = [\n        ...tokens\n    ];\n    while(tokenCopy.length > 0){\n        const stmt = parseStatement(tokenCopy, false);\n        if (stmt) ast.body.push(stmt);\n    }\n    return ast;\n}\nfunction parseStatement(tokens, insideLoop = false) {\n    if (tokens.length === 0) return null;\n    const token = tokens[0];\n    if (token.type === \"keyword\" && token.value === \"ye\") {\n        return parseDeclaration(tokens);\n    } else if (token.type === \"keyword\" && token.value === \"bol\") {\n        return parsePrintStatement(tokens);\n    } else if (token.type === \"keyword\" && token.value === \"agar\") {\n        return parseIfStatement(tokens, insideLoop);\n    } else if (token.type === \"keyword\" && token.value === \"jabtak\") {\n        return parseWhileStatement(tokens);\n    } else if (token.type === \"keyword\" && token.value === \"ke liye\") {\n        return parseForStatement(tokens);\n    } else if (token.type === \"keyword\" && token.value === \"break\") {\n        if (!insideLoop) throw new Error(\"break/continue outside loop\");\n        tokens.shift();\n        return {\n            type: \"BreakStatement\"\n        };\n    } else if (token.type === \"keyword\" && token.value === \"continue\") {\n        if (!insideLoop) throw new Error(\"break/continue outside loop\");\n        tokens.shift();\n        return {\n            type: \"ContinueStatement\"\n        };\n    } else if (token.type === \"identifier\") {\n        return parseAssignment(tokens);\n    }\n    tokens.shift();\n    return null;\n}\nfunction parseDeclaration(tokens) {\n    tokens.shift();\n    if (tokens.length === 0 || tokens[0].type !== \"identifier\") {\n        throw new Error('Expected identifier after \"ye\"');\n    }\n    const name = tokens.shift().value;\n    let value = null;\n    if (tokens.length > 0 && tokens[0].type === \"operator\" && tokens[0].value === \"=\") {\n        tokens.shift();\n        value = parseExpression(tokens);\n    }\n    return {\n        type: \"Declaration\",\n        name,\n        value\n    };\n}\nfunction parseAssignment(tokens) {\n    const name = tokens.shift().value;\n    if (tokens.length === 0 || tokens[0].type !== \"operator\" || tokens[0].value !== \"=\") {\n        throw new Error(`Expected \"=\" after identifier \"${name}\"`);\n    }\n    tokens.shift();\n    const value = parseExpression(tokens);\n    return {\n        type: \"Assignment\",\n        name,\n        value\n    };\n}\nfunction parsePrintStatement(tokens) {\n    tokens.shift();\n    if (tokens.length === 0) throw new Error('Expected value after \"bol\"');\n    const value = parseExpression(tokens);\n    return {\n        type: \"PrintStatement\",\n        value\n    };\n}\nfunction parseIfStatement(tokens, insideLoop = false) {\n    tokens.shift();\n    const condition = parseCondition(tokens);\n    if (tokens.length === 0 || tokens[0].type !== \"brace\" || tokens[0].value !== \"{\") {\n        throw new Error('Expected \"{\" after condition');\n    }\n    tokens.shift();\n    const body = parseBlock(tokens, insideLoop);\n    const elseIf = [];\n    let elseBody = null;\n    while(tokens.length > 0 && (tokens[0].value === \"nahi agar\" || tokens[0].value === \"nahi\")){\n        if (tokens[0].value === \"nahi agar\") {\n            tokens.shift();\n            const elifCondition = parseCondition(tokens);\n            if (tokens.length === 0 || tokens[0].value !== \"{\") throw new Error('Expected \"{\" after else-if');\n            tokens.shift();\n            const elifBody = parseBlock(tokens, insideLoop);\n            elseIf.push({\n                condition: elifCondition,\n                body: elifBody\n            });\n            continue;\n        }\n        if (tokens[0].value === \"nahi\") {\n            tokens.shift();\n            if (tokens.length === 0 || tokens[0].value !== \"{\") throw new Error('Expected \"{\" after nahi');\n            tokens.shift();\n            elseBody = parseBlock(tokens, insideLoop);\n            break;\n        }\n    }\n    return {\n        type: \"IfStatement\",\n        condition,\n        body,\n        elseIf,\n        elseBody\n    };\n}\nfunction parseWhileStatement(tokens) {\n    tokens.shift();\n    const condition = parseCondition(tokens);\n    if (tokens.length === 0 || tokens[0].type !== \"brace\" || tokens[0].value !== \"{\") {\n        throw new Error('Expected \"{\" after condition');\n    }\n    tokens.shift();\n    const body = parseBlock(tokens, true);\n    return {\n        type: \"WhileStatement\",\n        condition,\n        body\n    };\n}\nfunction parseForStatement(tokens) {\n    tokens.shift();\n    if (tokens.length === 0 || tokens[0].type !== \"identifier\") {\n        throw new Error(\"Expected identifier in for loop\");\n    }\n    const variable = tokens.shift().value;\n    if (tokens.length === 0 || tokens[0].type !== \"operator\" || tokens[0].value !== \"=\") {\n        throw new Error('Expected \"=\" in for loop');\n    }\n    tokens.shift();\n    const start = parseExpression(tokens);\n    if (tokens.length === 0 || !(tokens[0].type === \"keyword\" && tokens[0].value === \"tak\")) {\n        throw new Error('Expected \"tak\" in for loop');\n    }\n    tokens.shift();\n    const end = parseExpression(tokens);\n    if (tokens.length === 0 || tokens[0].type !== \"brace\" || tokens[0].value !== \"{\") {\n        throw new Error('Expected \"{\" after for condition');\n    }\n    tokens.shift();\n    const body = parseBlock(tokens, true);\n    return {\n        type: \"ForStatement\",\n        variable,\n        start,\n        end,\n        body\n    };\n}\nfunction parseCondition(tokens) {\n    const left = parseExpression(tokens);\n    if (tokens.length === 0 || tokens[0].type !== \"operator\" || !isComparisonOperator(tokens[0].value)) {\n        throw new Error(\"Expected comparison operator in condition\");\n    }\n    const operator = tokens.shift().value;\n    const right = parseExpression(tokens);\n    return {\n        left,\n        operator,\n        right\n    };\n}\nfunction isComparisonOperator(op) {\n    return [\n        \"==\",\n        \"!=\",\n        \"<\",\n        \">\",\n        \"<=\",\n        \">=\"\n    ].includes(op);\n}\n/**\r\n * Expression parsing with proper precedence:\r\n * Expression → Additive\r\n * Additive → Concatenation (+, -)\r\n * Concatenation → Multiplicative (.)\r\n * Multiplicative → Primary (*, /)\r\n * Primary → Number | String | Identifier | (Expression)\r\n */ function parseExpression(tokens) {\n    return parseAdditive(tokens);\n}\nfunction parseAdditive(tokens) {\n    let left = parseConcatenation(tokens);\n    while(tokens.length > 0 && tokens[0].type === \"operator\" && (tokens[0].value === \"+\" || tokens[0].value === \"-\")){\n        const op = tokens.shift().value;\n        const right = parseConcatenation(tokens);\n        left = {\n            type: \"BinaryOp\",\n            left,\n            operator: op,\n            right\n        };\n    }\n    return left;\n}\nfunction parseConcatenation(tokens) {\n    let left = parseMultiplicative(tokens);\n    while(tokens.length > 0 && tokens[0].type === \"operator\" && tokens[0].value === \".\"){\n        tokens.shift(); // consume '.'\n        const right = parseMultiplicative(tokens);\n        left = {\n            type: \"ConcatOp\",\n            left,\n            right\n        };\n    }\n    return left;\n}\nfunction parseMultiplicative(tokens) {\n    let left = parsePrimary(tokens);\n    while(tokens.length > 0 && tokens[0].type === \"operator\" && (tokens[0].value === \"*\" || tokens[0].value === \"/\")){\n        const op = tokens.shift().value;\n        const right = parsePrimary(tokens);\n        left = {\n            type: \"BinaryOp\",\n            left,\n            operator: op,\n            right\n        };\n    }\n    return left;\n}\nfunction parsePrimary(tokens) {\n    if (tokens.length === 0) throw new Error(\"Unexpected end of expression\");\n    const token = tokens[0];\n    if (token.type === \"paren\" && token.value === \"(\") {\n        tokens.shift();\n        const expr = parseExpression(tokens);\n        if (tokens.length === 0 || tokens[0].type !== \"paren\" || tokens[0].value !== \")\") {\n            throw new Error('Expected \")\" after expression');\n        }\n        tokens.shift();\n        return expr;\n    }\n    if (token.type === \"number\") {\n        tokens.shift();\n        return {\n            type: \"Number\",\n            value: parseInt(token.value, 10)\n        };\n    }\n    if (token.type === \"string\") {\n        tokens.shift();\n        return {\n            type: \"String\",\n            value: token.value\n        };\n    }\n    if (token.type === \"identifier\") {\n        tokens.shift();\n        return {\n            type: \"Identifier\",\n            value: token.value\n        };\n    }\n    throw new Error(`Unexpected token: ${token.value}`);\n}\nfunction parseBlock(tokens, insideLoop = false) {\n    const body = [];\n    while(tokens.length > 0){\n        if (tokens[0].type === \"brace\" && tokens[0].value === \"}\") {\n            tokens.shift();\n            break;\n        }\n        const stmt = parseStatement(tokens, insideLoop);\n        if (stmt) body.push(stmt);\n    }\n    return body;\n}\nmodule.exports = parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLO1FBQ1osT0FBTztZQUFFaEIsTUFBTTtZQUFjUyxPQUFPRCxNQUFNQyxLQUFLO1FBQUM7SUFDbEQ7SUFDQSxNQUFNLElBQUlNLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRVAsTUFBTUMsS0FBSyxDQUFDLENBQUM7QUFDcEQ7QUFDQSxTQUFTYSxXQUFXeEIsTUFBTSxFQUFFUyxhQUFhLEtBQUs7SUFDNUMsTUFBTU4sT0FBTyxFQUFFO0lBQ2YsTUFBT0gsT0FBT0ssTUFBTSxHQUFHLEVBQUc7UUFDeEIsSUFBSUwsTUFBTSxDQUFDLEVBQUUsQ0FBQ0UsSUFBSSxLQUFLLFdBQVdGLE1BQU0sQ0FBQyxFQUFFLENBQUNXLEtBQUssS0FBSyxLQUFLO1lBQ3pEWCxPQUFPa0IsS0FBSztZQUNaO1FBQ0Y7UUFDQSxNQUFNWixPQUFPQyxlQUFlUCxRQUFRUztRQUNwQyxJQUFJSCxNQUFNSCxLQUFLSyxJQUFJLENBQUNGO0lBQ3RCO0lBQ0EsT0FBT0g7QUFDVDtBQUNBeUMsT0FBT0MsT0FBTyxHQUFHOUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcHAtaWRlLy4vbGliL2pwcC9wYXJzZXIuanM/NThmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSisrIFBhcnNlciAtIEJ1aWxkcyBBU1QgZnJvbSB0b2tlbnNcclxuICogXHJcbiAqIE9QRVJBVE9SIFBSRUNFREVOQ0UgKGhpZ2hlc3QgdG8gbG93ZXN0KTpcclxuICogMS4gUHJpbWFyeSAobnVtYmVycywgc3RyaW5ncywgaWRlbnRpZmllcnMsIHBhcmVudGhlc2VzKVxyXG4gKiAyLiBNdWx0aXBsaWNhdGl2ZSAoKiwgLylcclxuICogMy4gQ29uY2F0ZW5hdGlvbiAoLikgLSBORVc6IHN0cmluZy1vbmx5XHJcbiAqIDQuIEFkZGl0aXZlICgrLCAtKSAtIG51bWVyaWMtb25seVxyXG4gKi9cclxuIGZ1bmN0aW9uIHBhcnNlcih0b2tlbnMpIHtcclxuICBjb25zdCBhc3QgPSB7XHJcbiAgICB0eXBlOiAnUHJvZ3JhbScsXHJcbiAgICBib2R5OiBbXVxyXG4gIH07XHJcbiAgY29uc3QgdG9rZW5Db3B5ID0gWy4uLnRva2Vuc107XHJcbiAgd2hpbGUgKHRva2VuQ29weS5sZW5ndGggPiAwKSB7XHJcbiAgICBjb25zdCBzdG10ID0gcGFyc2VTdGF0ZW1lbnQodG9rZW5Db3B5LCBmYWxzZSk7XHJcbiAgICBpZiAoc3RtdCkgYXN0LmJvZHkucHVzaChzdG10KTtcclxuICB9XHJcbiAgcmV0dXJuIGFzdDtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVN0YXRlbWVudCh0b2tlbnMsIGluc2lkZUxvb3AgPSBmYWxzZSkge1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICBjb25zdCB0b2tlbiA9IHRva2Vuc1swXTtcclxuICBpZiAodG9rZW4udHlwZSA9PT0gJ2tleXdvcmQnICYmIHRva2VuLnZhbHVlID09PSAneWUnKSB7XHJcbiAgICByZXR1cm4gcGFyc2VEZWNsYXJhdGlvbih0b2tlbnMpO1xyXG4gIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ2tleXdvcmQnICYmIHRva2VuLnZhbHVlID09PSAnYm9sJykge1xyXG4gICAgcmV0dXJuIHBhcnNlUHJpbnRTdGF0ZW1lbnQodG9rZW5zKTtcclxuICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdrZXl3b3JkJyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2FnYXInKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJZlN0YXRlbWVudCh0b2tlbnMsIGluc2lkZUxvb3ApO1xyXG4gIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ2tleXdvcmQnICYmIHRva2VuLnZhbHVlID09PSAnamFidGFrJykge1xyXG4gICAgcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQodG9rZW5zKTtcclxuICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdrZXl3b3JkJyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2tlIGxpeWUnKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGb3JTdGF0ZW1lbnQodG9rZW5zKTtcclxuICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdrZXl3b3JkJyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2JyZWFrJykge1xyXG4gICAgaWYgKCFpbnNpZGVMb29wKSB0aHJvdyBuZXcgRXJyb3IoJ2JyZWFrL2NvbnRpbnVlIG91dHNpZGUgbG9vcCcpO1xyXG4gICAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4geyB0eXBlOiAnQnJlYWtTdGF0ZW1lbnQnIH07XHJcbiAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAna2V5d29yZCcgJiYgdG9rZW4udmFsdWUgPT09ICdjb250aW51ZScpIHtcclxuICAgIGlmICghaW5zaWRlTG9vcCkgdGhyb3cgbmV3IEVycm9yKCdicmVhay9jb250aW51ZSBvdXRzaWRlIGxvb3AnKTtcclxuICAgIHRva2Vucy5zaGlmdCgpO1xyXG4gICAgcmV0dXJuIHsgdHlwZTogJ0NvbnRpbnVlU3RhdGVtZW50JyB9O1xyXG4gIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ2lkZW50aWZpZXInKSB7XHJcbiAgICByZXR1cm4gcGFyc2VBc3NpZ25tZW50KHRva2Vucyk7XHJcbiAgfVxyXG4gIHRva2Vucy5zaGlmdCgpO1xyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRGVjbGFyYXRpb24odG9rZW5zKSB7XHJcbiAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zWzBdLnR5cGUgIT09ICdpZGVudGlmaWVyJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpZGVudGlmaWVyIGFmdGVyIFwieWVcIicpO1xyXG4gIH1cclxuICBjb25zdCBuYW1lID0gdG9rZW5zLnNoaWZ0KCkudmFsdWU7XHJcbiAgbGV0IHZhbHVlID0gbnVsbDtcclxuICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zWzBdLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgdG9rZW5zWzBdLnZhbHVlID09PSAnPScpIHtcclxuICAgIHRva2Vucy5zaGlmdCgpO1xyXG4gICAgdmFsdWUgPSBwYXJzZUV4cHJlc3Npb24odG9rZW5zKTtcclxuICB9XHJcbiAgcmV0dXJuIHsgdHlwZTogJ0RlY2xhcmF0aW9uJywgbmFtZSwgdmFsdWUgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnQodG9rZW5zKSB7XHJcbiAgY29uc3QgbmFtZSA9IHRva2Vucy5zaGlmdCgpLnZhbHVlO1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1swXS50eXBlICE9PSAnb3BlcmF0b3InIHx8IHRva2Vuc1swXS52YWx1ZSAhPT0gJz0nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFwiPVwiIGFmdGVyIGlkZW50aWZpZXIgXCIke25hbWV9XCJgKTtcclxuICB9XHJcbiAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgY29uc3QgdmFsdWUgPSBwYXJzZUV4cHJlc3Npb24odG9rZW5zKTtcclxuICByZXR1cm4geyB0eXBlOiAnQXNzaWdubWVudCcsIG5hbWUsIHZhbHVlIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VQcmludFN0YXRlbWVudCh0b2tlbnMpIHtcclxuICB0b2tlbnMuc2hpZnQoKTtcclxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWx1ZSBhZnRlciBcImJvbFwiJyk7XHJcbiAgY29uc3QgdmFsdWUgPSBwYXJzZUV4cHJlc3Npb24odG9rZW5zKTtcclxuICByZXR1cm4geyB0eXBlOiAnUHJpbnRTdGF0ZW1lbnQnLCB2YWx1ZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQodG9rZW5zLCBpbnNpZGVMb29wID0gZmFsc2UpIHtcclxuICB0b2tlbnMuc2hpZnQoKTtcclxuICBjb25zdCBjb25kaXRpb24gPSBwYXJzZUNvbmRpdGlvbih0b2tlbnMpO1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1swXS50eXBlICE9PSAnYnJhY2UnIHx8IHRva2Vuc1swXS52YWx1ZSAhPT0gJ3snKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwie1wiIGFmdGVyIGNvbmRpdGlvbicpO1xyXG4gIH1cclxuICB0b2tlbnMuc2hpZnQoKTtcclxuICBjb25zdCBib2R5ID0gcGFyc2VCbG9jayh0b2tlbnMsIGluc2lkZUxvb3ApO1xyXG4gIGNvbnN0IGVsc2VJZiA9IFtdO1xyXG4gIGxldCBlbHNlQm9keSA9IG51bGw7XHJcbiAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwICYmXHJcbiAgICAodG9rZW5zWzBdLnZhbHVlID09PSAnbmFoaSBhZ2FyJyB8fCB0b2tlbnNbMF0udmFsdWUgPT09ICduYWhpJykpIHtcclxuICAgIGlmICh0b2tlbnNbMF0udmFsdWUgPT09ICduYWhpIGFnYXInKSB7XHJcbiAgICAgIHRva2Vucy5zaGlmdCgpO1xyXG4gICAgICBjb25zdCBlbGlmQ29uZGl0aW9uID0gcGFyc2VDb25kaXRpb24odG9rZW5zKTtcclxuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zWzBdLnZhbHVlICE9PSAneycpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgXCJ7XCIgYWZ0ZXIgZWxzZS1pZicpO1xyXG4gICAgICB0b2tlbnMuc2hpZnQoKTtcclxuICAgICAgY29uc3QgZWxpZkJvZHkgPSBwYXJzZUJsb2NrKHRva2VucywgaW5zaWRlTG9vcCk7XHJcbiAgICAgIGVsc2VJZi5wdXNoKHsgY29uZGl0aW9uOiBlbGlmQ29uZGl0aW9uLCBib2R5OiBlbGlmQm9keSB9KTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW5zWzBdLnZhbHVlID09PSAnbmFoaScpIHtcclxuICAgICAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1swXS52YWx1ZSAhPT0gJ3snKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwie1wiIGFmdGVyIG5haGknKTtcclxuICAgICAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgICAgIGVsc2VCb2R5ID0gcGFyc2VCbG9jayh0b2tlbnMsIGluc2lkZUxvb3ApO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6ICdJZlN0YXRlbWVudCcsXHJcbiAgICBjb25kaXRpb24sXHJcbiAgICBib2R5LFxyXG4gICAgZWxzZUlmLFxyXG4gICAgZWxzZUJvZHlcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlV2hpbGVTdGF0ZW1lbnQodG9rZW5zKSB7XHJcbiAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgY29uc3QgY29uZGl0aW9uID0gcGFyc2VDb25kaXRpb24odG9rZW5zKTtcclxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJ2JyYWNlJyB8fCB0b2tlbnNbMF0udmFsdWUgIT09ICd7Jykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcIntcIiBhZnRlciBjb25kaXRpb24nKTtcclxuICB9XHJcbiAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgY29uc3QgYm9keSA9IHBhcnNlQmxvY2sodG9rZW5zLCB0cnVlKTtcclxuICByZXR1cm4geyB0eXBlOiAnV2hpbGVTdGF0ZW1lbnQnLCBjb25kaXRpb24sIGJvZHkgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudCh0b2tlbnMpIHtcclxuICB0b2tlbnMuc2hpZnQoKTtcclxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJ2lkZW50aWZpZXInKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlkZW50aWZpZXIgaW4gZm9yIGxvb3AnKTtcclxuICB9XHJcbiAgY29uc3QgdmFyaWFibGUgPSB0b2tlbnMuc2hpZnQoKS52YWx1ZTtcclxuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJ29wZXJhdG9yJyB8fCB0b2tlbnNbMF0udmFsdWUgIT09ICc9Jykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcIj1cIiBpbiBmb3IgbG9vcCcpO1xyXG4gIH1cclxuICB0b2tlbnMuc2hpZnQoKTtcclxuICBjb25zdCBzdGFydCA9IHBhcnNlRXhwcmVzc2lvbih0b2tlbnMpO1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8ICEodG9rZW5zWzBdLnR5cGUgPT09ICdrZXl3b3JkJyAmJiB0b2tlbnNbMF0udmFsdWUgPT09ICd0YWsnKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcInRha1wiIGluIGZvciBsb29wJyk7XHJcbiAgfVxyXG4gIHRva2Vucy5zaGlmdCgpO1xyXG4gIGNvbnN0IGVuZCA9IHBhcnNlRXhwcmVzc2lvbih0b2tlbnMpO1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1swXS50eXBlICE9PSAnYnJhY2UnIHx8IHRva2Vuc1swXS52YWx1ZSAhPT0gJ3snKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwie1wiIGFmdGVyIGZvciBjb25kaXRpb24nKTtcclxuICB9XHJcbiAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgY29uc3QgYm9keSA9IHBhcnNlQmxvY2sodG9rZW5zLCB0cnVlKTtcclxuICByZXR1cm4geyB0eXBlOiAnRm9yU3RhdGVtZW50JywgdmFyaWFibGUsIHN0YXJ0LCBlbmQsIGJvZHkgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUNvbmRpdGlvbih0b2tlbnMpIHtcclxuICBjb25zdCBsZWZ0ID0gcGFyc2VFeHByZXNzaW9uKHRva2Vucyk7XHJcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdG9rZW5zWzBdLnR5cGUgIT09ICdvcGVyYXRvcicgfHwgIWlzQ29tcGFyaXNvbk9wZXJhdG9yKHRva2Vuc1swXS52YWx1ZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY29tcGFyaXNvbiBvcGVyYXRvciBpbiBjb25kaXRpb24nKTtcclxuICB9XHJcbiAgY29uc3Qgb3BlcmF0b3IgPSB0b2tlbnMuc2hpZnQoKS52YWx1ZTtcclxuICBjb25zdCByaWdodCA9IHBhcnNlRXhwcmVzc2lvbih0b2tlbnMpO1xyXG4gIHJldHVybiB7IGxlZnQsIG9wZXJhdG9yLCByaWdodCB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcGFyaXNvbk9wZXJhdG9yKG9wKSB7XHJcbiAgcmV0dXJuIFsnPT0nLCAnIT0nLCAnPCcsICc+JywgJzw9JywgJz49J10uaW5jbHVkZXMob3ApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHByZXNzaW9uIHBhcnNpbmcgd2l0aCBwcm9wZXIgcHJlY2VkZW5jZTpcclxuICogRXhwcmVzc2lvbiDihpIgQWRkaXRpdmVcclxuICogQWRkaXRpdmUg4oaSIENvbmNhdGVuYXRpb24gKCssIC0pXHJcbiAqIENvbmNhdGVuYXRpb24g4oaSIE11bHRpcGxpY2F0aXZlICguKVxyXG4gKiBNdWx0aXBsaWNhdGl2ZSDihpIgUHJpbWFyeSAoKiwgLylcclxuICogUHJpbWFyeSDihpIgTnVtYmVyIHwgU3RyaW5nIHwgSWRlbnRpZmllciB8IChFeHByZXNzaW9uKVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKHRva2Vucykge1xyXG4gIHJldHVybiBwYXJzZUFkZGl0aXZlKHRva2Vucyk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBZGRpdGl2ZSh0b2tlbnMpIHtcclxuICBsZXQgbGVmdCA9IHBhcnNlQ29uY2F0ZW5hdGlvbih0b2tlbnMpO1xyXG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbMF0udHlwZSA9PT0gJ29wZXJhdG9yJyAmJiBcclxuICAgICAgICAgKHRva2Vuc1swXS52YWx1ZSA9PT0gJysnIHx8IHRva2Vuc1swXS52YWx1ZSA9PT0gJy0nKSkge1xyXG4gICAgY29uc3Qgb3AgPSB0b2tlbnMuc2hpZnQoKS52YWx1ZTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VDb25jYXRlbmF0aW9uKHRva2Vucyk7XHJcbiAgICBsZWZ0ID0geyB0eXBlOiAnQmluYXJ5T3AnLCBsZWZ0LCBvcGVyYXRvcjogb3AsIHJpZ2h0IH07XHJcbiAgfVxyXG4gIHJldHVybiBsZWZ0O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQ29uY2F0ZW5hdGlvbih0b2tlbnMpIHtcclxuICBsZXQgbGVmdCA9IHBhcnNlTXVsdGlwbGljYXRpdmUodG9rZW5zKTtcclxuICB3aGlsZSAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zWzBdLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgdG9rZW5zWzBdLnZhbHVlID09PSAnLicpIHtcclxuICAgIHRva2Vucy5zaGlmdCgpOyAvLyBjb25zdW1lICcuJ1xyXG4gICAgY29uc3QgcmlnaHQgPSBwYXJzZU11bHRpcGxpY2F0aXZlKHRva2Vucyk7XHJcbiAgICBsZWZ0ID0geyB0eXBlOiAnQ29uY2F0T3AnLCBsZWZ0LCByaWdodCB9O1xyXG4gIH1cclxuICByZXR1cm4gbGVmdDtcclxufVxyXG5mdW5jdGlvbiBwYXJzZU11bHRpcGxpY2F0aXZlKHRva2Vucykge1xyXG4gIGxldCBsZWZ0ID0gcGFyc2VQcmltYXJ5KHRva2Vucyk7XHJcbiAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1swXS50eXBlID09PSAnb3BlcmF0b3InICYmIFxyXG4gICAgICAgICAodG9rZW5zWzBdLnZhbHVlID09PSAnKicgfHwgdG9rZW5zWzBdLnZhbHVlID09PSAnLycpKSB7XHJcbiAgICBjb25zdCBvcCA9IHRva2Vucy5zaGlmdCgpLnZhbHVlO1xyXG4gICAgY29uc3QgcmlnaHQgPSBwYXJzZVByaW1hcnkodG9rZW5zKTtcclxuICAgIGxlZnQgPSB7IHR5cGU6ICdCaW5hcnlPcCcsIGxlZnQsIG9wZXJhdG9yOiBvcCwgcmlnaHQgfTtcclxuICB9XHJcbiAgcmV0dXJuIGxlZnQ7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VQcmltYXJ5KHRva2Vucykge1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb24nKTtcclxuICBjb25zdCB0b2tlbiA9IHRva2Vuc1swXTtcclxuXHJcbiAgaWYgKHRva2VuLnR5cGUgPT09ICdwYXJlbicgJiYgdG9rZW4udmFsdWUgPT09ICcoJykge1xyXG4gICAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKHRva2Vucyk7XHJcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJ3BhcmVuJyB8fCB0b2tlbnNbMF0udmFsdWUgIT09ICcpJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwiKVwiIGFmdGVyIGV4cHJlc3Npb24nKTtcclxuICAgIH1cclxuICAgIHRva2Vucy5zaGlmdCgpO1xyXG4gICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG4gIGlmICh0b2tlbi50eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4geyB0eXBlOiAnTnVtYmVyJywgdmFsdWU6IHBhcnNlSW50KHRva2VuLnZhbHVlLCAxMCkgfTtcclxuICB9XHJcbiAgaWYgKHRva2VuLnR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB0b2tlbnMuc2hpZnQoKTtcclxuICAgIHJldHVybiB7IHR5cGU6ICdTdHJpbmcnLCB2YWx1ZTogdG9rZW4udmFsdWUgfTtcclxuICB9XHJcbiAgaWYgKHRva2VuLnR5cGUgPT09ICdpZGVudGlmaWVyJykge1xyXG4gICAgdG9rZW5zLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4geyB0eXBlOiAnSWRlbnRpZmllcicsIHZhbHVlOiB0b2tlbi52YWx1ZSB9O1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW46ICR7dG9rZW4udmFsdWV9YCk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VCbG9jayh0b2tlbnMsIGluc2lkZUxvb3AgPSBmYWxzZSkge1xyXG4gIGNvbnN0IGJvZHkgPSBbXTtcclxuICB3aGlsZSAodG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgIGlmICh0b2tlbnNbMF0udHlwZSA9PT0gJ2JyYWNlJyAmJiB0b2tlbnNbMF0udmFsdWUgPT09ICd9Jykge1xyXG4gICAgICB0b2tlbnMuc2hpZnQoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdG10ID0gcGFyc2VTdGF0ZW1lbnQodG9rZW5zLCBpbnNpZGVMb29wKTtcclxuICAgIGlmIChzdG10KSBib2R5LnB1c2goc3RtdCk7XHJcbiAgfVxyXG4gIHJldHVybiBib2R5O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyOyJdLCJuYW1lcyI6WyJwYXJzZXIiLCJ0b2tlbnMiLCJhc3QiLCJ0eXBlIiwiYm9keSIsInRva2VuQ29weSIsImxlbmd0aCIsInN0bXQiLCJwYXJzZVN0YXRlbWVudCIsInB1c2giLCJpbnNpZGVMb29wIiwidG9rZW4iLCJ2YWx1ZSIsInBhcnNlRGVjbGFyYXRpb24iLCJwYXJzZVByaW50U3RhdGVtZW50IiwicGFyc2VJZlN0YXRlbWVudCIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsIkVycm9yIiwic2hpZnQiLCJwYXJzZUFzc2lnbm1lbnQiLCJuYW1lIiwicGFyc2VFeHByZXNzaW9uIiwiY29uZGl0aW9uIiwicGFyc2VDb25kaXRpb24iLCJwYXJzZUJsb2NrIiwiZWxzZUlmIiwiZWxzZUJvZHkiLCJlbGlmQ29uZGl0aW9uIiwiZWxpZkJvZHkiLCJ2YXJpYWJsZSIsInN0YXJ0IiwiZW5kIiwibGVmdCIsImlzQ29tcGFyaXNvbk9wZXJhdG9yIiwib3BlcmF0b3IiLCJyaWdodCIsIm9wIiwiaW5jbHVkZXMiLCJwYXJzZUFkZGl0aXZlIiwicGFyc2VDb25jYXRlbmF0aW9uIiwicGFyc2VNdWx0aXBsaWNhdGl2ZSIsInBhcnNlUHJpbWFyeSIsImV4cHIiLCJwYXJzZUludCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/jpp/parser.js\n");

/***/ }),

/***/ "(rsc)/./lib/jpp/typeChecker.js":
/*!********************************!*\
  !*** ./lib/jpp/typeChecker.js ***!
  \********************************/
/***/ ((module) => {

eval("/**\r\n * J++ Type Checker - Enforces strict type safety\r\n * \r\n * RULES:\r\n * - + operator: ONLY numbers allowed\r\n * - . operator: ONLY strings allowed\r\n * - Variables remember their type from first assignment\r\n * - Reassigning incompatible types → ERROR\r\n * - Zero implicit coercion\r\n */ \nclass TypeChecker {\n    constructor(){\n        // Symbol table: variable name -> type ('number' | 'string')\n        this.symbols = new Map();\n    }\n    /**\r\n   * Infer type from AST node\r\n   */ inferType(node) {\n        if (!node) return null;\n        switch(node.type){\n            case \"Number\":\n                return \"number\";\n            case \"String\":\n                return \"string\";\n            case \"Identifier\":\n                const varType = this.symbols.get(node.value);\n                if (!varType) {\n                    throw new Error(`Variable \"${node.value}\" used before declaration`);\n                }\n                return varType;\n            case \"BinaryOp\":\n                if (node.operator === \"+\" || node.operator === \"-\" || node.operator === \"*\" || node.operator === \"/\") {\n                    const leftType = this.inferType(node.left);\n                    const rightType = this.inferType(node.right);\n                    if (leftType !== \"number\" || rightType !== \"number\") {\n                        throw new Error(`Operator \"${node.operator}\" requires numeric operands. ` + `Got: ${leftType || \"unknown\"} ${node.operator} ${rightType || \"unknown\"}`);\n                    }\n                    return \"number\";\n                }\n                throw new Error(`Unknown binary operator: ${node.operator}`);\n            case \"ConcatOp\":\n                const leftStrType = this.inferType(node.left);\n                const rightStrType = this.inferType(node.right);\n                if (leftStrType !== \"string\" || rightStrType !== \"string\") {\n                    throw new Error(`Operator \".\" requires string operands. ` + `Got: ${leftStrType || \"unknown\"} . ${rightStrType || \"unknown\"}`);\n                }\n                return \"string\";\n            default:\n                throw new Error(`Cannot infer type for node: ${node.type}`);\n        }\n    }\n    checkDeclaration(name, valueNode) {\n        if (this.symbols.has(name)) {\n            throw new Error(`Variable \"${name}\" already declared`);\n        }\n        if (valueNode) {\n            const type = this.inferType(valueNode);\n            this.symbols.set(name, type);\n        } else {\n            this.symbols.set(name, \"number\");\n        }\n    }\n    checkAssignment(name, valueNode) {\n        const existingType = this.symbols.get(name);\n        if (!existingType) {\n            throw new Error(`Variable \"${name}\" not declared`);\n        }\n        const newType = this.inferType(valueNode);\n        if (newType !== existingType) {\n            throw new Error(`Type mismatch: Cannot assign ${newType} to variable \"${name}\" of type ${existingType}`);\n        }\n    }\n    checkExpression(node) {\n        return this.inferType(node);\n    }\n    createScope() {\n        return new Map(this.symbols);\n    }\n    restoreScope(snapshot) {\n        this.symbols = new Map(snapshot);\n    }\n}\nmodule.exports = TypeChecker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNnQjtRQUMvQixJQUFJSyxZQUFZRCxjQUFjO1lBQzVCLE1BQU0sSUFBSWQsTUFDUixDQUFDLDZCQUE2QixFQUFFZSxRQUFRLGNBQWMsRUFBRU4sS0FBSyxVQUFVLEVBQUVLLGFBQWEsQ0FBQztRQUUzRjtJQUNGO0lBQ0FFLGdCQUFnQnJCLElBQUksRUFBRTtRQUNwQixPQUFPLElBQUksQ0FBQ0QsU0FBUyxDQUFDQztJQUN4QjtJQUNBc0IsY0FBYztRQUNaLE9BQU8sSUFBSXhCLElBQUksSUFBSSxDQUFDRCxPQUFPO0lBQzdCO0lBQ0EwQixhQUFhQyxRQUFRLEVBQUU7UUFDckIsSUFBSSxDQUFDM0IsT0FBTyxHQUFHLElBQUlDLElBQUkwQjtJQUN6QjtBQUNGO0FBQ0FDLE9BQU9DLE9BQU8sR0FBRy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanBwLWlkZS8uL2xpYi9qcHAvdHlwZUNoZWNrZXIuanM/MGFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogSisrIFR5cGUgQ2hlY2tlciAtIEVuZm9yY2VzIHN0cmljdCB0eXBlIHNhZmV0eVxyXG4gKiBcclxuICogUlVMRVM6XHJcbiAqIC0gKyBvcGVyYXRvcjogT05MWSBudW1iZXJzIGFsbG93ZWRcclxuICogLSAuIG9wZXJhdG9yOiBPTkxZIHN0cmluZ3MgYWxsb3dlZFxyXG4gKiAtIFZhcmlhYmxlcyByZW1lbWJlciB0aGVpciB0eXBlIGZyb20gZmlyc3QgYXNzaWdubWVudFxyXG4gKiAtIFJlYXNzaWduaW5nIGluY29tcGF0aWJsZSB0eXBlcyDihpIgRVJST1JcclxuICogLSBaZXJvIGltcGxpY2l0IGNvZXJjaW9uXHJcbiAqL1xyXG5jbGFzcyBUeXBlQ2hlY2tlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBTeW1ib2wgdGFibGU6IHZhcmlhYmxlIG5hbWUgLT4gdHlwZSAoJ251bWJlcicgfCAnc3RyaW5nJylcclxuICAgIHRoaXMuc3ltYm9scyA9IG5ldyBNYXAoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSW5mZXIgdHlwZSBmcm9tIEFTVCBub2RlXHJcbiAgICovXHJcbiAgaW5mZXJUeXBlKG5vZGUpIHtcclxuICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICBjYXNlICdOdW1iZXInOlxyXG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcclxuICAgICAgY2FzZSAnU3RyaW5nJzpcclxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxyXG4gICAgICAgIGNvbnN0IHZhclR5cGUgPSB0aGlzLnN5bWJvbHMuZ2V0KG5vZGUudmFsdWUpO1xyXG4gICAgICAgIGlmICghdmFyVHlwZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bm9kZS52YWx1ZX1cIiB1c2VkIGJlZm9yZSBkZWNsYXJhdGlvbmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFyVHlwZTtcclxuICAgICAgY2FzZSAnQmluYXJ5T3AnOlxyXG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSAnKycgfHwgbm9kZS5vcGVyYXRvciA9PT0gJy0nIHx8IG5vZGUub3BlcmF0b3IgPT09ICcqJyB8fCBub2RlLm9wZXJhdG9yID09PSAnLycpIHtcclxuICAgICAgICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5pbmZlclR5cGUobm9kZS5sZWZ0KTtcclxuICAgICAgICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuaW5mZXJUeXBlKG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAobGVmdFR5cGUgIT09ICdudW1iZXInIHx8IHJpZ2h0VHlwZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgIGBPcGVyYXRvciBcIiR7bm9kZS5vcGVyYXRvcn1cIiByZXF1aXJlcyBudW1lcmljIG9wZXJhbmRzLiBgICtcclxuICAgICAgICAgICAgICBgR290OiAke2xlZnRUeXBlIHx8ICd1bmtub3duJ30gJHtub2RlLm9wZXJhdG9yfSAke3JpZ2h0VHlwZSB8fCAndW5rbm93bid9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuICdudW1iZXInO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYmluYXJ5IG9wZXJhdG9yOiAke25vZGUub3BlcmF0b3J9YCk7XHJcbiAgICAgIGNhc2UgJ0NvbmNhdE9wJzpcclxuICAgICAgICBjb25zdCBsZWZ0U3RyVHlwZSA9IHRoaXMuaW5mZXJUeXBlKG5vZGUubGVmdCk7XHJcbiAgICAgICAgY29uc3QgcmlnaHRTdHJUeXBlID0gdGhpcy5pbmZlclR5cGUobm9kZS5yaWdodCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxlZnRTdHJUeXBlICE9PSAnc3RyaW5nJyB8fCByaWdodFN0clR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBPcGVyYXRvciBcIi5cIiByZXF1aXJlcyBzdHJpbmcgb3BlcmFuZHMuIGAgK1xyXG4gICAgICAgICAgICBgR290OiAke2xlZnRTdHJUeXBlIHx8ICd1bmtub3duJ30gLiAke3JpZ2h0U3RyVHlwZSB8fCAndW5rbm93bid9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xyXG4gICAgICBcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbmZlciB0eXBlIGZvciBub2RlOiAke25vZGUudHlwZX1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgY2hlY2tEZWNsYXJhdGlvbihuYW1lLCB2YWx1ZU5vZGUpIHtcclxuICAgIGlmICh0aGlzLnN5bWJvbHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmFyaWFibGUgXCIke25hbWV9XCIgYWxyZWFkeSBkZWNsYXJlZGApO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlTm9kZSkge1xyXG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5pbmZlclR5cGUodmFsdWVOb2RlKTtcclxuICAgICAgdGhpcy5zeW1ib2xzLnNldChuYW1lLCB0eXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3ltYm9scy5zZXQobmFtZSwgJ251bWJlcicpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjaGVja0Fzc2lnbm1lbnQobmFtZSwgdmFsdWVOb2RlKSB7XHJcbiAgICBjb25zdCBleGlzdGluZ1R5cGUgPSB0aGlzLnN5bWJvbHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKCFleGlzdGluZ1R5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBub3QgZGVjbGFyZWRgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1R5cGUgPSB0aGlzLmluZmVyVHlwZSh2YWx1ZU5vZGUpO1xyXG4gICAgaWYgKG5ld1R5cGUgIT09IGV4aXN0aW5nVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYFR5cGUgbWlzbWF0Y2g6IENhbm5vdCBhc3NpZ24gJHtuZXdUeXBlfSB0byB2YXJpYWJsZSBcIiR7bmFtZX1cIiBvZiB0eXBlICR7ZXhpc3RpbmdUeXBlfWBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLmluZmVyVHlwZShub2RlKTtcclxuICB9XHJcbiAgY3JlYXRlU2NvcGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLnN5bWJvbHMpO1xyXG4gIH1cclxuICByZXN0b3JlU2NvcGUoc25hcHNob3QpIHtcclxuICAgIHRoaXMuc3ltYm9scyA9IG5ldyBNYXAoc25hcHNob3QpO1xyXG4gIH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVDaGVja2VyOyJdLCJuYW1lcyI6WyJUeXBlQ2hlY2tlciIsImNvbnN0cnVjdG9yIiwic3ltYm9scyIsIk1hcCIsImluZmVyVHlwZSIsIm5vZGUiLCJ0eXBlIiwidmFyVHlwZSIsImdldCIsInZhbHVlIiwiRXJyb3IiLCJvcGVyYXRvciIsImxlZnRUeXBlIiwibGVmdCIsInJpZ2h0VHlwZSIsInJpZ2h0IiwibGVmdFN0clR5cGUiLCJyaWdodFN0clR5cGUiLCJjaGVja0RlY2xhcmF0aW9uIiwibmFtZSIsInZhbHVlTm9kZSIsImhhcyIsInNldCIsImNoZWNrQXNzaWdubWVudCIsImV4aXN0aW5nVHlwZSIsIm5ld1R5cGUiLCJjaGVja0V4cHJlc3Npb24iLCJjcmVhdGVTY29wZSIsInJlc3RvcmVTY29wZSIsInNuYXBzaG90IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/jpp/typeChecker.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexecute%2Froute&page=%2Fapi%2Fexecute%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexecute%2Froute.js&appDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CVRAJ%20SHAH%5CDesktop%5Cjide&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();